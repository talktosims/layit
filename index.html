<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="LayIt">
    <meta name="theme-color" content="#0d1117">
    <meta name="description" content="LayIt - Tile layout planner with laser projection export for DIY tile installation">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    <title>LayIt</title>

    <!-- Favicon for browser tab -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%231a1a2e'/><polygon points='50,15 70,27 70,52 50,65 30,52 30,27' fill='%234CAF50'/><polygon points='30,52 30,77 50,90 50,65' fill='%23FF9800'/><polygon points='70,52 70,77 50,90 50,65' fill='%23FF9800'/></svg>">
    
    <style>
        :root {
            --bg-base:       #080b12;
            --bg-surface:    #111827;
            --bg-elevated:   #1e293b;
            --bg-recessed:   #060810;
            --bg-overlay:    rgba(0,0,0,0.8);
            --accent:        #ef4444;
            --accent-hover:  #f87171;
            --accent-glow:   rgba(239,68,68,0.45);
            --accent-subtle: rgba(239,68,68,0.15);
            --success:       #22c55e;
            --success-hover: #4ade80;
            --success-glow:  rgba(34,197,94,0.40);
            --success-subtle:rgba(34,197,94,0.15);
            --warning:       #f59e0b;
            --warning-subtle:rgba(245,158,11,0.15);
            --info:          #3b82f6;
            --text-primary:  #f1f5f9;
            --text-secondary:#94a3b8;
            --text-tertiary: #475569;
            --text-on-accent:#ffffff;
            --border-default:rgba(148,163,184,0.12);
            --border-accent: rgba(239,68,68,0.50);
            --border-success:rgba(34,197,94,0.50);
            --border-input:  rgba(148,163,184,0.15);
            --space-1:4px; --space-2:8px; --space-3:12px; --space-4:16px; --space-5:20px; --space-6:24px; --space-8:32px;
            --font-family: -apple-system,BlinkMacSystemFont,'SF Pro Display','Segoe UI',system-ui,sans-serif;
            --text-xs:10px; --text-sm:11px; --text-base:13px; --text-md:14px; --text-lg:16px; --text-xl:18px; --text-2xl:24px; --text-3xl:32px;
            --leading-tight:1.2; --leading-normal:1.5; --leading-relaxed:1.7;
            --tracking-wide:0.04em;
            --radius-sm:8px; --radius-md:14px; --radius-lg:18px; --radius-xl:24px; --radius-pill:9999px;
            --shadow-sm:   0 2px 4px rgba(0,0,0,0.4);
            --shadow-md:   0 4px 16px rgba(0,0,0,0.5);
            --shadow-lg:   0 8px 32px rgba(0,0,0,0.6);
            --shadow-glow-accent:  0 0 24px var(--accent-glow), 0 0 6px var(--accent-glow);
            --shadow-glow-success: 0 0 24px var(--success-glow), 0 0 6px var(--success-glow);
            --shadow-inset: inset 0 2px 4px rgba(0,0,0,0.5);
            --ease-out:cubic-bezier(0.22,1,0.36,1);
            --ease-spring:cubic-bezier(0.34,1.56,0.64,1);
            --duration-fast:100ms; --duration-normal:200ms; --duration-slow:350ms;
        }

        * { box-sizing:border-box; margin:0; padding:0; }
        body {
            font-family:var(--font-family);
            background:var(--bg-base);
            color:var(--text-primary);
            line-height:var(--leading-normal);
            -webkit-tap-highlight-color:transparent;
            -webkit-font-smoothing:antialiased;
        }

        /* ---- TAB BAR ---- */
        .tabs {
            display:flex;
            position:sticky;
            top:0;
            z-index:100;
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 50%, #1e1b4b 100%);
            border-bottom:2px solid rgba(139,92,246,0.3);
            padding:0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .tab {
            flex:1;
            padding:8px 2px 10px;
            text-align:center;
            border:none;
            background:transparent;
            color:rgba(255,255,255,0.35);
            cursor:pointer;
            -webkit-appearance:none;
            position:relative;
            transition:all 0.2s ease;
            display:flex;
            flex-direction:column;
            align-items:center;
            gap:3px;
            min-width:0;
        }
        .tab-icon {
            font-size:18px;
            line-height:1;
            display:flex;
            align-items:center;
            justify-content:center;
            height:22px;
        }
        .tab-label {
            font-size:9px;
            font-weight:700;
            letter-spacing:0.04em;
            text-transform:uppercase;
            line-height:1;
            white-space:nowrap;
        }
        .hex-icon {
            display:block;
            filter:drop-shadow(0 0 4px rgba(74,222,128,0.4));
            transition:filter 0.2s ease;
        }
        .tab.active .hex-icon {
            filter:drop-shadow(0 0 8px rgba(74,222,128,0.7));
        }
        .tab.active .hex-icon path {
            stroke:#4ade80;
            stroke-width:3;
        }
        .tab::after {
            content:'';
            position:absolute;
            bottom:-2px;
            left:15%;
            right:15%;
            height:3px;
            border-radius:3px 3px 0 0;
            background:transparent;
            transition:all 0.25s var(--ease-out);
        }
        .tab.active {
            color:#fff;
            background:rgba(255,255,255,0.06);
        }
        .tab.active .tab-icon {
            text-shadow: 0 0 16px rgba(255,255,255,0.4);
        }
        .tab.active::after {
            background:linear-gradient(90deg, #8b5cf6, #ec4899);
            box-shadow: 0 0 12px rgba(139,92,246,0.6), 0 0 4px rgba(236,72,153,0.4);
        }
        @media(hover:hover){
            .tab:hover:not(.active){ color:rgba(255,255,255,0.6); background:rgba(255,255,255,0.04); }
        }

        /* ---- PANELS & SECTIONS ---- */
        .panel { display:none; padding:20px 16px; max-width:600px; margin:0 auto; }
        .panel.active { display:block; }

        .section {
            background: linear-gradient(145deg, #111827, #0f172a);
            border:1px solid rgba(148,163,184,0.1);
            border-left:4px solid var(--accent);
            border-radius:var(--radius-md);
            padding:20px;
            margin-bottom:20px;
            box-shadow: var(--shadow-md), inset 0 1px 0 rgba(255,255,255,0.03);
        }
        .section h3 {
            font-size:var(--text-md);
            font-weight:700;
            color:var(--text-primary);
            margin-bottom:16px;
            letter-spacing:var(--tracking-wide);
            text-transform:uppercase;
            padding-bottom:10px;
            border-bottom:1px solid rgba(148,163,184,0.1);
        }

        /* ---- FORM ELEMENTS ---- */
        .row { display:grid; grid-template-columns:1fr 1fr; gap:var(--space-3); margin-bottom:var(--space-3); }
        .field { margin-bottom:var(--space-4); }
        label {
            display:block;
            font-size:var(--text-sm);
            font-weight:600;
            color:var(--text-secondary);
            margin-bottom:6px;
            letter-spacing:var(--tracking-wide);
            text-transform:uppercase;
        }
        input, select {
            width:100%;
            padding:12px 14px;
            font-size:var(--text-lg);
            border:2px solid rgba(148,163,184,0.12);
            border-radius:var(--radius-sm);
            background:var(--bg-recessed);
            color:var(--text-primary);
            box-shadow:var(--shadow-inset);
            -webkit-appearance:none;
            appearance:none;
            transition:border-color 0.15s ease, box-shadow 0.15s ease;
        }
        input:focus, select:focus {
            outline:none;
            border-color:var(--accent);
            box-shadow:var(--shadow-inset), 0 0 0 4px var(--accent-glow);
        }
        input::placeholder { color:var(--text-tertiary); }
        select {
            background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%2394a3b8'%3E%3Cpath d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat:no-repeat;
            background-position:right 12px center;
            padding-right:32px;
        }
        input[type=number] { -moz-appearance:textfield; }
        input[type=number]::-webkit-inner-spin-button { -webkit-appearance:none; }

        input[type=range] {
            -webkit-appearance:none; appearance:none;
            height:8px;
            background:linear-gradient(90deg, rgba(139,92,246,0.3), rgba(236,72,153,0.3));
            border:none; border-radius:4px;
            box-shadow:none; outline:none; padding:0;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance:none;
            width:26px; height:26px;
            border-radius:50%;
            background:linear-gradient(135deg, #8b5cf6, #ec4899);
            box-shadow:0 0 12px rgba(139,92,246,0.5);
            cursor:pointer;
            border:2px solid rgba(255,255,255,0.2);
        }
        input[type=checkbox] {
            width:18px; height:18px;
            border-radius:4px;
            border:2px solid var(--border-input);
            background:var(--bg-recessed);
            box-shadow:none; cursor:pointer;
            accent-color:var(--accent);
        }

        /* ---- BUTTONS ---- */
        button {
            padding:14px 20px;
            font-size:var(--text-md);
            font-weight:700;
            border:none;
            border-radius:var(--radius-md);
            width:100%;
            margin-top:var(--space-3);
            cursor:pointer;
            -webkit-appearance:none;
            letter-spacing:0.02em;
            transition:all 0.15s ease;
        }
        button:active { transform:scale(0.96); }
        button:disabled { opacity:0.35; cursor:not-allowed; transform:none; }

        .btn-primary {
            background:linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color:#fff;
            box-shadow: 0 4px 14px rgba(239,68,68,0.4);
        }
        .btn-secondary {
            background:var(--bg-elevated);
            color:var(--text-primary);
            border:2px solid rgba(148,163,184,0.15);
        }
        .btn-success {
            background:linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color:#fff;
            box-shadow: 0 4px 14px rgba(34,197,94,0.35);
        }
        @media(hover:hover){
            .btn-primary:hover:not(:disabled){
                box-shadow: 0 6px 24px rgba(239,68,68,0.5);
                transform:translateY(-1px);
            }
            .btn-secondary:hover:not(:disabled){
                background:rgba(255,255,255,0.08);
                border-color:rgba(148,163,184,0.25);
            }
            .btn-success:hover:not(:disabled){
                box-shadow: 0 6px 24px rgba(34,197,94,0.5);
                transform:translateY(-1px);
            }
        }

        /* ---- CANVAS ---- */
        #canvasContainer {
            background:#fff;
            border-radius:var(--radius-md);
            overflow:hidden;
            box-shadow: 0 0 0 1px rgba(148,163,184,0.1), var(--shadow-lg);
        }
        canvas { display:block; width:100%; touch-action:pan-x pan-y; }

        /* ---- INFO BAR ---- */
        .info-bar {
            background:linear-gradient(135deg, #1e293b, #0f172a);
            border:1px solid rgba(148,163,184,0.1);
            padding:14px 16px;
            border-radius:var(--radius-md);
            font-size:15px;
            font-weight:600;
            text-align:center;
            margin-bottom:16px;
            box-shadow:var(--shadow-sm);
            letter-spacing:0.02em;
        }
        .full { color:#22c55e; }
        .partial { color:#f59e0b; }

        /* ---- VOID ITEMS ---- */
        .void-item {
            display:flex;
            justify-content:space-between;
            align-items:center;
            background:var(--bg-recessed);
            padding:14px;
            border-radius:var(--radius-sm);
            margin-top:10px;
            font-size:var(--text-base);
            border:1px solid rgba(148,163,184,0.08);
            border-left:3px solid var(--warning);
        }
        .void-item button { width:auto; padding:8px 14px; margin:0; }

        /* ---- CALCULATOR ---- */
        .calc-result {
            font-size:36px;
            font-weight:800;
            color:var(--success);
            text-align:center;
            margin:16px 0;
            letter-spacing:-0.02em;
            text-shadow: 0 0 30px rgba(34,197,94,0.3);
        }

        /* ---- PROJECTOR ---- */
        .proj-ctrl {
            position:fixed; top:12px; right:12px; z-index:1001;
            display:flex; gap:8px;
        }
        .proj-btn {
            padding:16px 20px;
            font-size:var(--text-xl);
            background:rgba(15,23,42,0.9);
            -webkit-backdrop-filter:blur(12px);
            backdrop-filter:blur(12px);
            color:#fff;
            border:1px solid rgba(255,255,255,0.15);
            border-radius:var(--radius-md);
            cursor:pointer;
        }

        /* ---- PROJECT ITEMS ---- */
        .project-item {
            display:flex;
            justify-content:space-between;
            align-items:center;
            background:var(--bg-recessed);
            padding:16px;
            border-radius:var(--radius-md);
            margin-bottom:10px;
            border:1px solid rgba(148,163,184,0.08);
            border-left:3px solid var(--info);
            transition:all 0.15s ease;
        }
        .project-item.active {
            border-left-color:var(--success);
            border-color:var(--border-success);
            background:var(--success-subtle);
        }
        .project-item-info { flex:1; }
        .project-item-name { font-size:15px; font-weight:700; color:var(--text-primary); }
        .project-item-date { font-size:var(--text-xs); color:var(--text-tertiary); margin-top:3px; }
        .project-item-actions { display:flex; gap:8px; }
        .project-item-actions button { width:auto; padding:8px 14px; margin:0; font-size:var(--text-base); }

        /* ---- MODALS ---- */
        .modal-overlay {
            display:none;
            position:fixed; top:0; left:0; right:0; bottom:0;
            background:rgba(0,0,0,0.85);
            -webkit-backdrop-filter:blur(12px);
            backdrop-filter:blur(12px);
            z-index:2000;
            align-items:center; justify-content:center;
        }
        .modal-overlay.active { display:flex; }
        .modal-box {
            background:linear-gradient(145deg, #1e293b, #0f172a);
            border:1px solid rgba(148,163,184,0.15);
            border-top:3px solid var(--accent);
            border-radius:var(--radius-lg);
            padding:28px;
            max-width:340px;
            width:calc(100% - 40px);
            text-align:center;
            box-shadow: 0 25px 60px rgba(0,0,0,0.6);
            animation:modalIn 0.3s var(--ease-spring);
        }
        @keyframes modalIn {
            from { opacity:0; transform:scale(0.9) translateY(12px); }
            to   { opacity:1; transform:scale(1) translateY(0); }
        }
        .modal-box h3 { color:var(--accent); margin-bottom:12px; font-size:20px; font-weight:700; }
        .modal-box p { color:var(--text-secondary); margin-bottom:24px; font-size:15px; line-height:1.6; }
        .modal-buttons { display:flex; gap:12px; }
        .modal-buttons button { flex:1; padding:14px; font-size:var(--text-lg); border:none; border-radius:var(--radius-md); cursor:pointer; font-weight:700; }
        .modal-cancel { background:var(--bg-elevated); color:var(--text-primary); border:2px solid rgba(148,163,184,0.12); }
        .modal-confirm { background:linear-gradient(135deg, #ef4444, #dc2626); color:#fff; box-shadow:0 4px 14px rgba(239,68,68,0.35); }

        /* ---- OPTIMIZE MENU ---- */
        .optimize-option {
            padding:14px 18px;
            color:var(--text-primary);
            cursor:pointer;
            border-bottom:1px solid rgba(148,163,184,0.08);
            font-size:15px;
            font-weight:500;
            transition:all 0.12s ease;
        }
        .optimize-option:last-child { border-bottom:none; }
        .optimize-option:hover { background:var(--success); color:#fff; }

        /* ---- TILE DETAIL VIEW ---- */
        .detail-overlay {
            display:none;
            position:fixed; top:0; left:0; right:0; bottom:0;
            background:rgba(0,0,0,0.95);
            -webkit-backdrop-filter:blur(8px);
            backdrop-filter:blur(8px);
            z-index:2500;
            flex-direction:column;
        }
        .detail-overlay.active { display:flex; }
        .detail-header {
            padding:14px 20px;
            text-align:center;
            color:#fbbf24;
            font-size:20px;
            font-weight:800;
            background:linear-gradient(135deg, rgba(15,23,42,0.95), rgba(30,27,75,0.95));
            border-bottom:2px solid rgba(139,92,246,0.3);
            text-shadow:0 0 20px rgba(251,191,36,0.3);
        }
        .detail-canvas-container {
            flex:1;
            display:flex; align-items:center; justify-content:center;
            padding:12px; overflow:hidden; touch-action:none;
        }
        .detail-canvas-container canvas {
            background:#fff;
            border-radius:var(--radius-md);
            touch-action:none; cursor:grab;
            box-shadow: 0 0 0 1px rgba(255,255,255,0.1), var(--shadow-lg);
        }
        .detail-canvas-container canvas:active { cursor:grabbing; }
        .detail-footer {
            padding:16px 20px;
            display:flex; gap:12px;
            background:linear-gradient(135deg, rgba(15,23,42,0.95), rgba(30,27,75,0.95));
            border-top:2px solid rgba(139,92,246,0.3);
        }
        .detail-footer button {
            flex:1; padding:16px; font-size:var(--text-lg); font-weight:800;
            border:none; border-radius:var(--radius-md); cursor:pointer;
        }
        .detail-close { background:var(--bg-elevated); color:var(--text-primary); border:2px solid rgba(148,163,184,0.12); }
        .detail-done { background:linear-gradient(135deg, #22c55e, #16a34a); color:#fff; box-shadow:0 4px 20px rgba(34,197,94,0.4); }

        /* ---- TOAST ---- */
        .toast-notification {
            position:fixed; bottom:80px; left:50%; transform:translateX(-50%);
            background:linear-gradient(135deg, #1e293b, #0f172a);
            color:#fff;
            padding:14px 24px;
            border-radius:var(--radius-pill);
            font-size:14px;
            font-weight:600;
            z-index:9999;
            max-width:90%;
            text-align:center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            border:1px solid rgba(139,92,246,0.3);
            animation:toastIn 0.25s var(--ease-spring);
        }
        @keyframes toastIn {
            from { opacity:0; transform:translateX(-50%) translateY(10px) scale(0.95); }
            to   { opacity:1; transform:translateX(-50%) translateY(0) scale(1); }
        }

        /* ---- UTILITIES ---- */
        .flex-row     { display:flex; align-items:center; gap:12px; }
        .flex-between { display:flex; justify-content:space-between; align-items:center; }
        .flex-center  { display:flex; align-items:center; justify-content:center; }
        .grid-2       { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
        .grid-3       { display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; }
        .mb-1{margin-bottom:4px;} .mb-2{margin-bottom:8px;} .mb-3{margin-bottom:12px;} .mb-4{margin-bottom:16px;}
        .mt-2{margin-top:8px;} .mt-3{margin-top:12px;} .mt-4{margin-top:16px;}
        .text-xs{font-size:10px;} .text-sm{font-size:11px;} .text-base{font-size:13px;}
        .text-center{text-align:center;} .text-muted{color:var(--text-secondary);} .text-dim{color:var(--text-tertiary);}
        .text-success{color:var(--success);} .text-accent{color:var(--accent);} .text-bold{font-weight:700;}
        .hint { font-size:11px; color:var(--text-tertiary); text-align:center; line-height:1.7; }

        .stat-box {
            background:linear-gradient(145deg, #1e293b, #0f172a);
            border-radius:var(--radius-md);
            padding:16px;
            text-align:center;
            border:1px solid rgba(148,163,184,0.1);
            box-shadow:var(--shadow-sm);
        }
        .stat-box .stat-label  { font-size:10px; color:var(--text-secondary); text-transform:uppercase; letter-spacing:0.05em; font-weight:600; }
        .stat-box .stat-value  { font-size:22px; font-weight:800; color:var(--text-primary); margin:4px 0; }
        .stat-box .stat-detail { font-size:10px; color:var(--text-tertiary); }

        .progress-bar { background:rgba(255,255,255,0.06); border-radius:5px; height:10px; overflow:hidden; }
        .progress-bar-fill {
            background:linear-gradient(90deg, #22c55e, #4ade80);
            height:100%; transition:width 0.35s ease; border-radius:5px;
            box-shadow:0 0 8px rgba(34,197,94,0.3);
        }

        .proj-top-bar {
            position:fixed; top:0; left:0; right:0;
            background:rgba(8,11,18,0.92);
            -webkit-backdrop-filter:blur(16px); backdrop-filter:blur(16px);
            padding:14px 20px;
            display:flex; justify-content:space-between; align-items:center;
            z-index:1003;
            border-bottom:2px solid rgba(139,92,246,0.3);
        }
        .proj-bottom-bar {
            position:fixed; bottom:20px; left:50%; transform:translateX(-50%);
            display:flex; gap:12px; z-index:1003;
        }
        /* ---- MEASUREMENT WIZARD ---- */
        .wizard-overlay {
            position:fixed; top:0; left:0; right:0; bottom:0;
            background:var(--bg-base);
            z-index:200;
            display:flex; flex-direction:column;
            overflow-y:auto;
            -webkit-overflow-scrolling:touch;
        }
        .wizard-overlay.hidden { display:none; }
        .wizard-header {
            text-align:center;
            padding:30px 20px 10px;
        }
        .wizard-header h2 {
            font-size:var(--text-2xl);
            font-weight:700;
            margin-bottom:6px;
            background:linear-gradient(135deg,#4ade80,#22c55e);
            -webkit-background-clip:text;
            -webkit-text-fill-color:transparent;
        }
        .wizard-header p {
            color:var(--text-secondary);
            font-size:var(--text-base);
            line-height:var(--leading-relaxed);
        }
        .wizard-steps {
            padding:10px 20px 20px;
            flex:1;
        }
        .wizard-step {
            background:var(--bg-surface);
            border:1px solid var(--border-default);
            border-radius:var(--radius-lg);
            padding:20px;
            margin-bottom:14px;
            transition:all var(--duration-normal) var(--ease-out);
        }
        .wizard-step.active {
            border-color:var(--success);
            box-shadow:0 0 20px rgba(34,197,94,0.15);
        }
        .wizard-step.completed {
            border-color:rgba(34,197,94,0.3);
            opacity:0.7;
        }
        .wizard-step-num {
            display:inline-flex; align-items:center; justify-content:center;
            width:28px; height:28px;
            border-radius:50%;
            background:var(--bg-elevated);
            border:2px solid var(--text-tertiary);
            font-size:var(--text-sm);
            font-weight:700;
            color:var(--text-secondary);
            margin-right:10px;
            flex-shrink:0;
        }
        .wizard-step.active .wizard-step-num {
            background:var(--success);
            border-color:var(--success);
            color:#fff;
        }
        .wizard-step.completed .wizard-step-num {
            background:rgba(34,197,94,0.2);
            border-color:var(--success);
            color:var(--success);
        }
        .wizard-step-header {
            display:flex; align-items:center;
            margin-bottom:10px;
        }
        .wizard-step-title {
            font-size:var(--text-md);
            font-weight:600;
            color:var(--text-primary);
        }
        .wizard-step.completed .wizard-step-title { color:var(--text-secondary); }
        .wizard-step-body {
            padding-left:38px;
            color:var(--text-secondary);
            font-size:var(--text-base);
            line-height:var(--leading-relaxed);
        }
        .wizard-step-body .wiz-icon {
            display:block;
            text-align:center;
            font-size:48px;
            margin:12px 0;
            opacity:0.9;
        }
        .wizard-step-body .wiz-visual {
            background:var(--bg-recessed);
            border:1px solid var(--border-default);
            border-radius:var(--radius-md);
            padding:16px;
            margin:12px 0;
            text-align:center;
        }
        .wizard-step-body .wiz-tip {
            background:var(--warning-subtle);
            border-left:3px solid var(--warning);
            padding:8px 12px;
            border-radius:0 var(--radius-sm) var(--radius-sm) 0;
            margin:10px 0;
            font-size:var(--text-sm);
            color:var(--text-primary);
        }
        .wizard-actions {
            padding:10px 20px 30px;
            display:flex;
            gap:10px;
        }
        .wizard-actions button {
            flex:1;
            padding:14px;
            border-radius:var(--radius-md);
            border:none;
            font-size:var(--text-md);
            font-weight:600;
            cursor:pointer;
            transition:all var(--duration-normal) var(--ease-out);
        }
        .wiz-btn-primary {
            background:linear-gradient(135deg,#22c55e,#16a34a);
            color:#fff;
            box-shadow:0 0 20px rgba(34,197,94,0.3);
        }
        .wiz-btn-primary:active { transform:scale(0.97); }
        .wiz-btn-secondary {
            background:var(--bg-elevated);
            color:var(--text-secondary);
            border:1px solid var(--border-default) !important;
        }
        .wizard-method-cards {
            display:grid;
            grid-template-columns:1fr;
            gap:10px;
            margin:10px 0;
        }
        .wiz-method-card {
            background:var(--bg-elevated);
            border:2px solid var(--border-default);
            border-radius:var(--radius-md);
            padding:14px;
            cursor:pointer;
            transition:all var(--duration-normal) var(--ease-out);
            text-align:left;
        }
        .wiz-method-card:active { transform:scale(0.98); }
        .wiz-method-card.selected {
            border-color:var(--success);
            background:rgba(34,197,94,0.08);
            box-shadow:0 0 16px rgba(34,197,94,0.15);
        }
        .wiz-method-card h4 {
            font-size:var(--text-md);
            color:var(--text-primary);
            margin-bottom:4px;
        }
        .wiz-method-card p {
            font-size:var(--text-sm);
            color:var(--text-secondary);
            line-height:var(--leading-normal);
        }
        .wiz-method-card .wiz-badge {
            display:inline-block;
            background:var(--success);
            color:#fff;
            font-size:9px;
            font-weight:700;
            padding:2px 6px;
            border-radius:var(--radius-pill);
            text-transform:uppercase;
            letter-spacing:0.05em;
            margin-left:6px;
            vertical-align:middle;
        }
        .wiz-quick-inputs {
            margin:12px 0;
        }
        .wiz-quick-inputs label {
            display:block;
            font-size:var(--text-sm);
            color:var(--text-secondary);
            margin-bottom:4px;
            margin-top:10px;
        }
        .wiz-quick-inputs input {
            width:100%;
            padding:12px 14px;
            background:var(--bg-recessed);
            border:1px solid var(--border-input);
            border-radius:var(--radius-md);
            color:var(--text-primary);
            font-size:var(--text-lg);
            font-weight:600;
            text-align:center;
            transition:border-color var(--duration-normal);
        }
        .wiz-quick-inputs input:focus {
            outline:none;
            border-color:var(--success);
            box-shadow:0 0 0 3px rgba(34,197,94,0.2);
        }
        .wiz-quick-inputs .wiz-input-row {
            display:grid;
            grid-template-columns:1fr 1fr;
            gap:10px;
        }
        .wiz-format-btns {
            display:flex; gap:6px; margin:8px 0;
        }
        .wiz-format-btn {
            flex:1; padding:8px;
            background:var(--bg-recessed);
            border:1px solid var(--border-default);
            border-radius:var(--radius-sm);
            color:var(--text-secondary);
            font-size:var(--text-sm);
            cursor:pointer;
            text-align:center;
        }
        .wiz-format-btn.active {
            background:rgba(34,197,94,0.1);
            border-color:var(--success);
            color:var(--success);
        }
        .wiz-progress {
            display:flex; gap:4px;
            padding:0 20px; margin-bottom:10px;
        }
        .wiz-progress-dot {
            flex:1; height:3px;
            background:var(--bg-elevated);
            border-radius:2px;
            transition:background var(--duration-normal);
        }
        .wiz-progress-dot.filled { background:var(--success); }
        .wiz-progress-dot.current { background:var(--success); opacity:0.5; }

    </style>
</head>
<body>
    <!-- Measurement Wizard Overlay -->
    <div id="measureWizard" class="wizard-overlay hidden">
        <div class="wizard-header">
            <h2>Measure Your Space</h2>
            <p>Let's get the dimensions of the area you want to tile</p>
        </div>

        <div class="wiz-progress" id="wizProgress">
            <div class="wiz-progress-dot filled"></div>
            <div class="wiz-progress-dot"></div>
            <div class="wiz-progress-dot"></div>
        </div>

        <!-- STEP 1: Choose method -->
        <div class="wizard-steps" id="wizStep1">
            <div class="wizard-step active">
                <div class="wizard-step-header">
                    <span class="wizard-step-num">1</span>
                    <span class="wizard-step-title">What are you tiling?</span>
                </div>
                <div class="wizard-step-body">
                    <div class="wizard-method-cards" id="wizSurfaceCards">
                        <div class="wiz-method-card selected" onclick="wizSelectSurface('wall', this)">
                            <h4>üß± A Wall</h4>
                            <p>Backsplash, shower wall, accent wall, fireplace surround</p>
                        </div>
                        <div class="wiz-method-card" onclick="wizSelectSurface('floor', this)">
                            <h4>üè† A Floor</h4>
                            <p>Bathroom floor, kitchen floor, entryway, patio</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="wizard-step active" style="margin-top:6px;">
                <div class="wizard-step-header">
                    <span class="wizard-step-num">2</span>
                    <span class="wizard-step-title">What shape is it?</span>
                </div>
                <div class="wizard-step-body">
                    <div class="wizard-method-cards" id="wizShapeCards">
                        <div class="wiz-method-card selected" onclick="wizSelectShape('rectangle', this)">
                            <h4>‚ñ≠ Simple Rectangle <span class="wiz-badge">Most Common</span></h4>
                            <p>Standard rectangular wall or floor area ‚Äî just need width and height</p>
                        </div>
                        <div class="wiz-method-card" onclick="wizSelectShape('custom', this)">
                            <h4>‚¨° Custom Shape</h4>
                            <p>L-shaped, angled, or irregular area ‚Äî draw the exact outline</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="wizard-actions" id="wizActions1">
            <button class="wiz-btn-secondary" onclick="closeWizard()">Skip</button>
            <button class="wiz-btn-primary" onclick="wizNext(1)">Next ‚Üí</button>
        </div>

        <!-- STEP 2: Enter measurements (Rectangle) -->
        <div class="wizard-steps" id="wizStep2" style="display:none;">
            <div class="wizard-step active">
                <div class="wizard-step-header">
                    <span class="wizard-step-num">3</span>
                    <span class="wizard-step-title" id="wizMeasureTitle">Grab Your Tape Measure</span>
                </div>
                <div class="wizard-step-body">
                    <div class="wiz-visual" id="wizMeasureVisual">
                        <div style="position:relative;width:200px;height:140px;margin:0 auto;">
                            <!-- Wall SVG Diagram -->
                            <svg viewBox="0 0 200 140" width="200" height="140">
                                <!-- Wall rectangle -->
                                <rect x="30" y="15" width="140" height="100" rx="3" fill="none" stroke="#4ade80" stroke-width="2" stroke-dasharray="6,3"/>
                                <!-- Width arrow -->
                                <line x1="30" y1="128" x2="170" y2="128" stroke="#f59e0b" stroke-width="1.5"/>
                                <polygon points="30,128 37,125 37,131" fill="#f59e0b"/>
                                <polygon points="170,128 163,125 163,131" fill="#f59e0b"/>
                                <text x="100" y="140" text-anchor="middle" fill="#f59e0b" font-size="11" font-weight="600">WIDTH</text>
                                <!-- Height arrow -->
                                <line x1="18" y1="15" x2="18" y2="115" stroke="#3b82f6" stroke-width="1.5"/>
                                <polygon points="18,15 15,22 21,22" fill="#3b82f6"/>
                                <polygon points="18,115 15,108 21,108" fill="#3b82f6"/>
                                <text x="9" y="70" text-anchor="middle" fill="#3b82f6" font-size="11" font-weight="600" transform="rotate(-90,9,70)">HEIGHT</text>
                                <!-- Tile grid hint -->
                                <line x1="30" y1="40" x2="170" y2="40" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/>
                                <line x1="30" y1="65" x2="170" y2="65" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/>
                                <line x1="30" y1="90" x2="170" y2="90" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/>
                                <line x1="75" y1="15" x2="75" y2="115" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/>
                                <line x1="120" y1="15" x2="120" y2="115" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/>
                            </svg>
                        </div>
                    </div>

                    <p style="margin-bottom:8px;">Measure the <strong style="color:var(--text-primary)">total area</strong> you want to tile:</p>

                    <div class="wiz-format-btns" id="wizFormatBtns">
                        <button class="wiz-format-btn active" onclick="wizSetFormat('inches', this)">Inches</button>
                        <button class="wiz-format-btn" onclick="wizSetFormat('feet', this)">Feet & Inches</button>
                    </div>

                    <div class="wiz-quick-inputs" id="wizInchInputs">
                        <div class="wiz-input-row">
                            <div>
                                <label style="color:#f59e0b;">Width (inches)</label>
                                <input type="number" id="wizWidth" placeholder="58" inputmode="decimal" autocomplete="off">
                            </div>
                            <div>
                                <label style="color:#3b82f6;">Height (inches)</label>
                                <input type="number" id="wizHeight" placeholder="70" inputmode="decimal" autocomplete="off">
                            </div>
                        </div>
                    </div>

                    <div class="wiz-quick-inputs" id="wizFeetInputs" style="display:none;">
                        <label style="color:#f59e0b;">Width</label>
                        <div class="wiz-input-row">
                            <div>
                                <input type="number" id="wizWidthFt" placeholder="4" inputmode="numeric" autocomplete="off">
                                <div style="text-align:center;font-size:10px;color:var(--text-tertiary);margin-top:2px;">feet</div>
                            </div>
                            <div>
                                <input type="number" id="wizWidthIn" placeholder="10" inputmode="decimal" autocomplete="off">
                                <div style="text-align:center;font-size:10px;color:var(--text-tertiary);margin-top:2px;">inches</div>
                            </div>
                        </div>
                        <label style="color:#3b82f6;">Height</label>
                        <div class="wiz-input-row">
                            <div>
                                <input type="number" id="wizHeightFt" placeholder="5" inputmode="numeric" autocomplete="off">
                                <div style="text-align:center;font-size:10px;color:var(--text-tertiary);margin-top:2px;">feet</div>
                            </div>
                            <div>
                                <input type="number" id="wizHeightIn" placeholder="10" inputmode="decimal" autocomplete="off">
                                <div style="text-align:center;font-size:10px;color:var(--text-tertiary);margin-top:2px;">inches</div>
                            </div>
                        </div>
                    </div>

                    <div class="wiz-tip">
                        <strong>Tip:</strong> Measure the actual tile area, not the whole wall. If your backsplash goes from counter to cabinets, measure just that space.
                    </div>
                </div>
            </div>
        </div>

        <div class="wizard-actions" id="wizActions2" style="display:none;">
            <button class="wiz-btn-secondary" onclick="wizBack(2)">‚Üê Back</button>
            <button class="wiz-btn-primary" onclick="wizApply()">Apply & Design ‚Üí</button>
        </div>

        <!-- STEP 3: Custom shape redirect -->
        <div class="wizard-steps" id="wizStep3" style="display:none;">
            <div class="wizard-step active">
                <div class="wizard-step-header">
                    <span class="wizard-step-num">3</span>
                    <span class="wizard-step-title">Draw Your Shape</span>
                </div>
                <div class="wizard-step-body">
                    <span class="wiz-icon">‚úèÔ∏è</span>
                    <p>For custom shapes, you'll use the <strong style="color:var(--text-primary)">drawing tool</strong>:</p>
                    <ol style="margin:12px 0; padding-left:18px; line-height:2;">
                        <li><strong>Tap each corner</strong> of your area on the canvas</li>
                        <li>Tap the <strong>first point again</strong> (or hit Close) to finish the shape</li>
                        <li><strong>Enter the measurement</strong> for each wall segment</li>
                        <li>Hit <strong>"Apply Dimensions"</strong> and you're done!</li>
                    </ol>
                    <div class="wiz-tip">
                        <strong>Tip:</strong> Start at the bottom-left corner and work clockwise. Don't worry about being pixel-perfect ‚Äî the exact measurements you enter are what matter.
                    </div>
                </div>
            </div>
        </div>

        <div class="wizard-actions" id="wizActions3" style="display:none;">
            <button class="wiz-btn-secondary" onclick="wizBack(3)">‚Üê Back</button>
            <button class="wiz-btn-primary" onclick="wizGoToDrawing()">Open Drawing Tool ‚Üí</button>
        </div>
    </div>

    <!-- Tile Detail View -->
    <div class="detail-overlay" id="detailOverlay">
        <div class="detail-header">üìê Tile Cut Detail</div>
        <div class="detail-canvas-container" id="detailCanvasContainer">
            <canvas id="detailCanvas" width="600" height="600"></canvas>
        </div>
        <div class="hint" style="padding:5px;">Pinch to zoom ‚Ä¢ Drag to pan</div>
        <div class="detail-footer">
            <button class="detail-close" onclick="closeDetailView(false)">‚úï Close</button>
            <button class="detail-done" onclick="closeDetailView(true)">‚úì Mark as Cut</button>
        </div>
    </div>

    <!-- Uncut confirmation modal -->
    <div class="modal-overlay" id="uncutModal">
        <div class="modal-box">
            <h3>‚ö†Ô∏è Uncut Tile?</h3>
            <p>Reset this tile back to pending (orange)?</p>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeUncutModal(false)">Cancel</button>
                <button class="modal-confirm" onclick="closeUncutModal(true)">Yes, Reset</button>
            </div>
        </div>
    </div>

    <!-- Unlock warning modal -->
    <div class="modal-overlay" id="unlockModal">
        <div class="modal-box">
            <h3>‚ö†Ô∏è Unlock Pattern?</h3>
            <p id="unlockWarningText">You have tiles marked. Moving the pattern will make your cut progress INVALID.</p>
            <div class="modal-buttons">
                <button class="modal-cancel" onclick="closeUnlockModal(false)">Keep Locked</button>
                <button class="modal-confirm" onclick="closeUnlockModal(true)">Unlock Anyway</button>
            </div>
        </div>
    </div>

    <div class="tabs" id="tabBar">
        <button class="tab active" data-tab="diagram"><span class="tab-icon">üìê</span><span class="tab-label">Layout</span></button>
        <button class="tab" data-tab="wall"><span class="tab-icon">üß±</span><span class="tab-label">Wall</span></button>
        <button class="tab" data-tab="tile"><span class="tab-icon">üî∑</span><span class="tab-label">Tile</span></button>
        <button class="tab" data-tab="voids"><span class="tab-icon">‚¨õ</span><span class="tab-label">Voids</span></button>
        <button class="tab" data-tab="calc"><span class="tab-icon">üî¢</span><span class="tab-label">Calc</span></button>
        <button class="tab" data-tab="projects"><span class="tab-icon">üìÅ</span><span class="tab-label">Files</span></button>
        <button class="tab" data-tab="proj"><span class="tab-icon"><svg class="hex-icon" viewBox="0 0 24 24" width="18" height="18"><path d="M12 2 L21.5 7.5 L21.5 16.5 L12 22 L2.5 16.5 L2.5 7.5 Z" fill="none" stroke="#4ade80" stroke-width="2.5" stroke-linejoin="round"/></svg></span><span class="tab-label">Laser</span></button>
    </div>

    <div id="diagram" class="panel active">
        <div class="info-bar">
            <span class="full">‚óè Full: <b id="fullCount">0</b></span> &nbsp;
            <span style="color:var(--accent)">‚óè Done: <b id="cutDoneCount">0</b></span>
        </div>
        <div class="hint mb-3">Tap cut tile to cycle: Orange ‚Üí Yellow (selected) ‚Üí Red (cut) ‚Üí Orange</div>
        <div class="flex-row mb-3">
            <span>üîç</span><input type="range" id="zoom" min="4" max="100" value="5" step="1" oninput="updateZoom()" style="flex:1"><span id="zoomVal">5x</span>
        </div>
        <div class="mb-3">
            <button id="lockBtn" class="btn-secondary" onclick="toggleLock()" style="display:flex;align-items:center;justify-content:center;gap:6px;">
                <span id="lockIcon">üîì</span> <span id="lockText">Unlocked</span>
            </button>
        </div>
        <div class="hint mb-3" id="controlsHint">üì± One finger: pattern ‚Ä¢ Two fingers: pan & zoom | üíª Drag: pattern ‚Ä¢ Shift+drag: pan ‚Ä¢ Scroll: zoom</div>
        <div class="row">
            <button class="btn-secondary" onclick="resetView()">üìç Reset View</button>
            <div style="position:relative;flex:1;">
                <button class="btn-success" onclick="toggleOptimizeMenu()" style="width:100%;" id="optimizeBtn">üéØ Optimize</button>
                <div id="optimizeMenu" style="display:none;position:absolute;bottom:100%;left:0;right:0;background:var(--bg-surface);border:1px solid var(--border-success);border-radius:var(--radius-md);margin-bottom:5px;overflow:hidden;z-index:100;box-shadow:var(--shadow-md);">
                    <div class="optimize-option" onclick="runOptimize('fullTiles')">üì¶ Maximize Full Tiles</div>
                    <div class="optimize-option" onclick="runOptimize('minSmallCuts')">üî™ Avoid Small Slivers</div>
                    <div class="optimize-option" onclick="runOptimize('balanced')">‚öñÔ∏è Balanced (Both)</div>
                </div>
            </div>
        </div>
        <button id="restoreBtn" class="btn-primary" onclick="restorePattern()" style="display:none;margin-bottom:10px;background:#ff9800;">‚ö†Ô∏è Restore Saved Pattern Position</button>
        <div id="canvasContainer"><canvas id="canvas"></canvas></div>
    </div>

    <div id="wall" class="panel">
        <div class="section">
            <h3>üìê Surface Perimeter</h3>
            <p class="hint mb-3" style="text-align:left;">Draw the outline of your wall or floor. Tap corners to create shape, then enter exact measurements.</p>
            
            <!-- Mode Toggle -->
            <div class="grid-2 mb-4">
                <button id="perimWallBtn" class="btn-primary" onclick="setPerimeterMode('wall')" style="padding:10px;font-size:13px;">
                    üß± Wall
                </button>
                <button id="perimFloorBtn" class="btn-secondary" onclick="setPerimeterMode('floor')" style="padding:10px;font-size:13px;">
                    üè† Floor
                </button>
            </div>
            
            <!-- Drawing Canvas -->
            <div id="perimeterCanvasContainer" style="background:var(--bg-recessed);border-radius:var(--radius-md);overflow:hidden;margin-bottom:15px;position:relative;border:1px solid var(--border-default);">
                <canvas id="perimeterCanvas" width="400" height="300" style="width:100%;touch-action:none;"></canvas>
                <div id="perimeterHint" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;color:var(--text-tertiary);font-size:12px;pointer-events:none;">
                    Tap to add corners<br>Tap first point to close shape
                </div>
            </div>
            
            <!-- Drawing Controls -->
            <div id="drawingControls" class="grid-3 mb-4">
                <button class="btn-secondary" onclick="undoPerimeterPoint()" id="undoBtn" disabled style="font-size:12px;padding:10px;">
                    ‚Ü© Undo
                </button>
                <button class="btn-secondary" onclick="clearPerimeter()" style="font-size:12px;padding:10px;">
                    üóë Clear
                </button>
                <button class="btn-success" onclick="closePerimeter()" id="closeBtn" disabled style="font-size:12px;padding:10px;">
                    ‚úì Close
                </button>
            </div>
            
            <!-- Status -->
            <div id="perimeterStatus" class="hint mb-4">
                Points: 0 | Tap to start drawing
            </div>
        </div>
        
        <!-- Wall Segments List (appears after shape is closed) -->
        <div class="section" id="segmentMeasurements" style="display:none;">
            <h3>üìè Enter Measurements</h3>
            <p class="hint mb-3" style="text-align:left;">Tap a wall segment below or on the drawing to enter its length.</p>
            
            <div id="wallSegmentsList">
                <!-- Filled by JS -->
            </div>
            
            <div id="measurementStatus" class="stat-box mt-4">
                <div class="stat-label">Segments measured</div>
                <div class="stat-value" id="measuredCount">0 / 0</div>
            </div>

            <div class="grid-2 mt-4">
                <button class="btn-secondary" onclick="undoLastMeasurement()" id="undoMeasureBtn" disabled>
                    ‚Ü© Undo Last
                </button>
                <button class="btn-primary" onclick="applyPerimeter()" id="applyPerimBtn" disabled>
                    ‚úì Apply Dimensions
                </button>
            </div>
        </div>
        
        <!-- Quick Rectangle Mode (for simple shapes) -->
        <div class="section">
            <h3>‚ö° Quick Rectangle</h3>
            <p class="hint mb-3" style="text-align:left;">For simple rectangular areas</p>
            <div class="row">
                <div class="field"><label>Width (in)</label><input type="number" id="quickWidth" placeholder="58"></div>
                <div class="field"><label>Height (in)</label><input type="number" id="quickHeight" placeholder="70"></div>
            </div>
            <button class="btn-secondary" onclick="applyQuickRectangle()" style="width:100%;">
                Apply Rectangle
            </button>
        </div>
    </div>

    <div id="tile" class="panel">
        <div class="section"><h3>Tile Settings</h3>
            <div class="field"><label>Preset</label><select id="tilePreset" onchange="applyPreset()"><option value="custom">Custom (enter below)</option></select></div>
            <div class="row">
                <div class="field"><label>Shape</label><select id="tileShape" onchange="onShape()"><option value="hexagon">Hexagon</option><option value="square">Square</option><option value="rectangle">Rectangle</option><option value="herringbone" selected>Herringbone</option></select></div>
                <div class="field" id="orientDiv"><label>Orientation</label><select id="tileOrient"><option value="pointy">45¬∞ Right</option><option value="flat">45¬∞ Left</option></select></div>
            </div>
            <div class="row" id="patternDiv" style="display:none;">
                <div class="field"><label>Pattern</label><select id="tilePattern" onchange="updateTile()">
                    <option value="0">Stack Bond (0%)</option>
                    <option value="0.5" selected>1/2 Brick (50%)</option>
                    <option value="0.333">1/3 Brick (33%)</option>
                    <option value="0.667">2/3 Brick (67%)</option>
                </select></div>
            </div>
            <div class="field" style="margin-bottom:6px;">
                <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:11px;">
                    <input type="checkbox" id="nominalMode" onchange="onNominalToggle()" style="margin:0;">
                    <span>Nominal size (box label) ‚Äî auto-subtract grout</span>
                </label>
            </div>
            <div class="row">
                <div class="field"><label id="tileWLabel">Actual Width (in)</label><input type="number" id="tileW" value="2" step="any"></div>
                <div class="field"><label id="tileHLabel">Actual Height (in)</label><input type="number" id="tileH" value="4" step="any"></div>
            </div>
            <div id="nominalHint" style="display:none;font-size:var(--text-xs);color:var(--success);margin:-4px 0 6px 2px;">‚úì Actual size will be calculated: nominal ‚àí grout joint</div>
            <div id="actualReadout" style="display:none;font-size:var(--text-sm);color:var(--info);background:rgba(59,130,246,0.1);padding:6px 8px;border-radius:4px;margin-bottom:8px;"></div>
            <div class="field"><label>Grout</label><select id="grout" onchange="onNominalToggle()"><option value="0.0625">1/16"</option><option value="0.125" selected>1/8"</option><option value="0.25">1/4"</option></select></div>
            <button class="btn-primary" onclick="updateTile()">üîÑ Update</button>
            <button class="btn-secondary" onclick="saveCustomPreset()" style="margin-top:4px;width:100%;font-size:11px;">üíæ Save as Preset</button>
            <p class="hint" style="margin-top:6px;text-align:left;">üí° Measure the tile face, not the box label. Or check "Nominal" to enter the box size and let the app calculate actual.</p>
        </div>
    </div>

    <div id="voids" class="panel">
        <div class="section"><h3>Voids</h3>
            <div class="field"><label>Label</label><input type="text" id="voidLabel" placeholder="Niche"></div>
            <div class="row"><div class="field"><label>From Left</label><input type="number" id="voidX"></div><div class="field"><label>From Bottom</label><input type="number" id="voidY"></div></div>
            <div class="row"><div class="field"><label>Width</label><input type="number" id="voidW"></div><div class="field"><label>Height</label><input type="number" id="voidH"></div></div>
            <button class="btn-success" onclick="addVoid()">+ Add</button>
            <div id="voidList"></div>
        </div>
    </div>

    <div id="calc" class="panel">
        <div class="section"><h3>üßÆ Tile Calculator</h3>
            <div class="field"><label>Waste % (recommended 10-15%)</label><input type="number" id="waste" value="10"></div>
            <button class="btn-primary" onclick="updateTileCount()" style="margin-bottom:10px;">üî¢ Calculate Tiles</button>
            <div class="calc-result" id="tilesNeeded">0 tiles</div>
            <div class="hint mt-3">
                Full tiles + Cut tiles + Waste buffer
            </div>
        </div>
        <div class="section"><h3>üí∞ Cost Estimate</h3>
            <div class="field"><label>Price per Tile ($)</label><input type="number" id="tilePrice" value="5" step="0.01"></div>
            <div class="field"><label>Price per Box (optional)</label>
                <div class="grid-2">
                    <input type="number" id="boxPrice" placeholder="Box $" step="0.01">
                    <input type="number" id="tilesPerBox" placeholder="Tiles/box">
                </div>
            </div>
            <button class="btn-primary" onclick="updateCostEstimate()" style="margin-bottom:10px;">üí∞ Calculate Cost</button>
            <div class="calc-result" id="costEstimate">$0.00</div>
            <div class="hint" id="costBreakdown"></div>
        </div>
    </div>

    <div id="projects" class="panel">
        <div class="section">
            <h3>üìÅ Current Project</h3>
            <div class="field">
                <label>Project Name</label>
                <input type="text" id="projName" placeholder="My Tile Project" oninput="markUnsaved()">
            </div>
            <div id="saveStatus" class="hint mb-3" style="text-align:left;">Not saved yet</div>
            <div class="grid-2">
                <button class="btn-primary" onclick="saveCurrentProject()">üíæ Save</button>
                <button class="btn-secondary" onclick="confirmNewProject()">üìÑ New</button>
            </div>
        </div>
        
        <div class="section">
            <h3>üìã My Projects</h3>
            <div id="projectList" style="max-height:250px;overflow-y:auto;">
                <!-- Filled by JS -->
            </div>
            <div id="noProjects" class="hint" style="padding:20px;">
                No saved projects yet.<br>Save your first project above!
            </div>
        </div>
        
        <div class="section">
            <h3>üì§ Backup & Share</h3>
            <p class="hint mb-3" style="text-align:left;">Export to share or backup. Import to restore.</p>
            <div class="grid-2">
                <button class="btn-secondary" onclick="exportProject()">üì§ Export</button>
                <button class="btn-secondary" onclick="document.getElementById('importFile').click()">üì• Import</button>
            </div>
            <input type="file" id="importFile" accept=".json" style="display:none" onchange="importProject(event)">
        </div>
    </div>

    <div id="proj" class="panel">
        <!-- Laser Position & Coverage Section -->
        <div class="section">
            <h3>üìè Laser Position</h3>
            
            <!-- Wall / Floor Toggle -->
            <div class="grid-2 mb-4">
                <button id="wallModeBtn" class="btn-primary" onclick="setProjectionSurface('wall')">
                    üß± Wall
                </button>
                <button id="floorModeBtn" class="btn-secondary" onclick="setProjectionSurface('floor')">
                    üè† Floor
                </button>
            </div>
            
            <!-- When laser NOT connected: show inputs -->
            <div id="distanceInputSection">
                
                <!-- Wall Mode Inputs -->
                <div id="wallInputs">
                    <label>Distance from wall</label>
                    <div class="flex-row" style="margin:10px 0;">
                        <input type="range" id="distanceSlider" min="3" max="15" value="6" step="0.5" 
                               oninput="updateFromDistance()" style="flex:1;">
                        <span id="distanceValue" style="font-size:var(--text-xl);font-weight:bold;color:var(--text-primary);min-width:50px;">6 ft</span>
                    </div>
                </div>
                
                <!-- Floor Mode Inputs -->
                <div id="floorInputs" style="display:none;">
                    <div class="mb-3">
                        <label>Tripod height</label>
                        <div class="flex-row" style="margin-top:6px;">
                            <input type="range" id="tripodHeightSlider" min="2" max="6" value="4" step="0.5" 
                                   oninput="updateFloorCoverage()" style="flex:1;">
                            <span id="tripodHeightValue" style="font-size:var(--text-lg);font-weight:bold;color:var(--text-primary);min-width:45px;">4 ft</span>
                        </div>
                    </div>
                    <div>
                        <label>Distance to work area</label>
                        <div class="flex-row" style="margin-top:6px;">
                            <input type="range" id="floorDistanceSlider" min="3" max="12" value="5" step="0.5" 
                                   oninput="updateFloorCoverage()" style="flex:1;">
                            <span id="floorDistanceValue" style="font-size:var(--text-lg);font-weight:bold;color:var(--text-primary);min-width:45px;">5 ft</span>
                        </div>
                    </div>
                    <div class="hint" style="margin-top:10px;padding:10px;background:var(--bg-base);border-radius:var(--radius-sm);">
                        üí° Position tripod at edge of room, angled down toward floor
                    </div>
                </div>
            </div>
            
            <!-- When laser connected: show detected values -->
            <div id="detectedDistanceSection" style="display:none;">
                <div class="stat-box" style="background:var(--success-subtle);border-color:var(--border-success);">
                    <div class="stat-label" style="color:var(--success);">‚óè Laser Connected</div>
                    <div class="stat-value" id="detectedDistance">6.2 ft</div>
                    <div class="stat-detail" id="detectedDistanceLabel">from wall (detected)</div>
                </div>
            </div>
            
            <!-- Coverage & Quality Result -->
            <div id="coverageResult" style="margin-top:15px;">
                <!-- Filled by JS -->
            </div>
        </div>
        
        <!-- Projection Mode Section -->
        <div class="section" id="projectionModeSection">
            <h3>üìê Projection</h3>
            
            <!-- Full Wall Mode -->
            <div id="fullWallMode" style="display:none;">
                <div class="stat-box mb-4" style="background:var(--success-subtle);border-color:var(--border-success);">
                    <div style="font-size:28px;">‚úì</div>
                    <div style="font-size:var(--text-lg);color:var(--success);font-weight:bold;">Full Wall Coverage</div>
                    <div class="stat-detail" style="margin-top:4px;">No segments needed</div>
                </div>
                
                <button class="btn-primary" onclick="projectFullWall()" style="font-size:18px;padding:20px;">
                    üî¥ Project Full Wall
                </button>
            </div>
            
            <!-- Segmented Mode -->
            <div id="segmentedMode" style="display:none;">
                <div id="segmentGrid" style="margin-bottom:15px;">
                    <!-- Filled by JS -->
                </div>
                
                <div id="segmentInfo" style="text-align:center;margin-bottom:15px;">
                    <!-- Filled by JS -->
                </div>
                
                <button id="projectSegmentBtn" class="btn-primary" onclick="projectCurrentSegment()" style="font-size:18px;padding:20px;">
                    üî¥ Project Segment 1
                </button>
                
                <button id="markCompleteBtn" class="btn-success" onclick="markSegmentComplete()" style="margin-top:10px;width:100%;display:none;">
                    ‚úì Mark Segment Complete
                </button>
            </div>
            
            <!-- No Wall Dimensions -->
            <div id="noWallMode">
                <div class="hint" style="padding:20px;">
                    <div style="font-size:var(--text-md);">Enter wall dimensions first</div>
                    <div style="font-size:var(--text-base);margin-top:5px;">üß± Wall tab</div>
                </div>
            </div>
        </div>
        
        <!-- Export Section (simple) -->
        <div class="section">
            <h3>üíæ Export File</h3>
            <div class="field">
                <label>Format</label>
                <select id="laserFormat">
                    <option value="layit">LayIt Laser (.layit)</option>
                    <option value="svg">SVG Vector (.svg)</option>
                    <option value="dxf">DXF CAD (.dxf)</option>
                </select>
            </div>
            <button class="btn-secondary" onclick="exportLaser()" style="width:100%;">
                üì• Download
            </button>
        </div>
        
        <!-- Laser Connection Section -->
        <div class="section">
            <h3>üì° Connect to LayIt Laser</h3>
            <p class="hint mb-3" style="text-align:left;">Connect directly to your LayIt Laser device via WiFi.</p>
            
            <div id="laserNotConnected">
                <div class="field">
                    <label>Laser Device</label>
                    <select id="laserDevice">
                        <option value="">Scanning...</option>
                    </select>
                </div>
                
                <button class="btn-success" onclick="connectLaser()" style="padding:15px;width:100%">
                    üîó Connect to Laser
                </button>
                
                <button class="btn-secondary" onclick="scanLasers()" style="margin-top:8px;width:100%">
                    üîÑ Scan for Devices
                </button>
            </div>
            
            <div id="laserConnected" style="display:none;">
                <div class="stat-box mb-3" style="background:var(--success-subtle);border-color:var(--border-success);">
                    <div class="stat-label" style="color:var(--success);">‚óè Connected</div>
                    <div class="stat-value" id="laserDeviceName">LayIt Laser Pro</div>
                    <div class="stat-detail" id="laserStatus">Ready to project</div>
                </div>
                
                <button class="btn-primary" onclick="sendToLaser()" style="padding:15px;width:100%;font-size:16px;">
                    üî¥ Project Pattern
                </button>
                
                <div class="grid-2 mt-3">
                    <button class="btn-secondary" onclick="laserPreview()">üëÅÔ∏è Preview</button>
                    <button class="btn-secondary" onclick="laserStop()">‚èπÔ∏è Stop</button>
                </div>
                
                <button class="btn-secondary" onclick="disconnectLaser()" style="margin-top:10px;background:#992222;width:100%">
                    üîå Disconnect
                </button>
            </div>
        </div>
        
        <!-- Laser Calibration Section -->
        <div class="section">
            <h3>üéØ Laser Calibration</h3>
            <p class="hint mb-3" style="text-align:left;">Calibrate your laser for accurate 1:1 scale projection.</p>
            
            <button class="btn-secondary" onclick="startLaserCalibration()" style="padding:15px;width:100%">
                üìè Start Calibration
            </button>
            
            <div style="margin-top:10px;font-size:var(--text-sm);color:var(--text-tertiary);line-height:1.6">
                <b>Calibration Steps:</b><br>
                1. Laser projects a 12" square<br>
                2. Measure with tape measure<br>
                3. Adjust until sides = 12"<br>
                4. Save calibration to device
            </div>
        </div>
        
        <!-- Laser Info Section -->
        <div class="section">
            <h3>üí° About LayIt Laser</h3>
            <div style="font-size:var(--text-sm);color:var(--text-secondary);line-height:1.8">
                <b style="color:var(--accent)">What It Does:</b><br>
                Projects your exact tile pattern onto walls/floors using a precision laser system. No more chalk lines or guesswork!<br><br>
                
                <b style="color:var(--accent)">Features:</b><br>
                ‚Ä¢ 1:1 scale projection<br>
                ‚Ä¢ WiFi connected to this app<br>
                ‚Ä¢ Works in daylight (green laser)<br>
                ‚Ä¢ Battery or plug-in powered<br><br>
                
                <b style="color:var(--accent)">Don't have a LayIt Laser?</b><br>
                Export your pattern as SVG/DXF and use with any laser cutter or CNC for templates.
            </div>
        </div>
    </div>

<script>
// Projector setup variables
var projSection = 'full'; // 'full', 'TL', 'TR', 'BL', 'BR'
var calibrationMode = false;

// ==================== SEGMENT PROJECTION SYSTEM ====================

var segmentState = {
    surface: 'wall',     // 'wall' or 'floor'
    distance: 6,         // feet from wall (wall mode)
    tripodHeight: 4,     // feet (floor mode)
    floorDistance: 5,    // horizontal feet to work area (floor mode)
    coverage: 52,        // inches - calculated from distance
    segments: [],        
    currentSegment: 0,
    enabled: false
};

// Set projection surface (wall or floor)
function setProjectionSurface(surface) {
    segmentState.surface = surface;
    
    // Update toggle buttons
    var wallBtn = document.getElementById('wallModeBtn');
    var floorBtn = document.getElementById('floorModeBtn');
    var wallInputs = document.getElementById('wallInputs');
    var floorInputs = document.getElementById('floorInputs');
    
    if (surface === 'wall') {
        wallBtn.className = 'btn-primary';
        floorBtn.className = 'btn-secondary';
        wallInputs.style.display = 'block';
        floorInputs.style.display = 'none';
        updateFromDistance();
    } else {
        wallBtn.className = 'btn-secondary';
        floorBtn.className = 'btn-primary';
        wallInputs.style.display = 'none';
        floorInputs.style.display = 'block';
        updateFloorCoverage();
    }
}

// Calculate coverage from distance (based on ¬±20¬∞ galvo scan angle)
function getCoverageFromDistance(distanceFt) {
    // At distance d, coverage ‚âà 2 * d * tan(20¬∞) ‚âà 0.73 * d (in same units)
    // Convert feet to inches, apply formula
    return Math.round(distanceFt * 12 * 0.73);
}

// Calculate floor coverage (more complex due to angle)
function getFloorCoverage(tripodHeightFt, horizontalDistFt) {
    // Beam travels along hypotenuse
    var beamDistance = Math.sqrt(tripodHeightFt * tripodHeightFt + horizontalDistFt * horizontalDistFt);
    
    // Base coverage from beam distance
    var baseCoverage = getCoverageFromDistance(beamDistance);
    
    // Angle affects effective coverage - steeper angle = more compression near, stretch far
    // Calculate angle (from horizontal)
    var angleDeg = Math.atan(tripodHeightFt / horizontalDistFt) * (180 / Math.PI);
    
    // Keystone correction compensates, but effective usable area is reduced
    // At 45¬∞, lose about 15%. At 30¬∞, lose about 10%. At 60¬∞, lose about 25%.
    var angleEfficiency = 1 - (Math.abs(angleDeg - 35) * 0.005); // Sweet spot around 35¬∞
    angleEfficiency = Math.max(0.7, Math.min(1, angleEfficiency));
    
    return Math.round(baseCoverage * angleEfficiency);
}

// Get effective beam distance for quality calculation (floor mode)
function getFloorBeamDistance(tripodHeightFt, horizontalDistFt) {
    return Math.sqrt(tripodHeightFt * tripodHeightFt + horizontalDistFt * horizontalDistFt);
}

// Get line quality info based on distance
function getLineQuality(distanceFt) {
    if (distanceFt <= 4) {
        return { label: 'Excellent', color: '#4CAF50', icon: '‚úì', width: '1-2mm' };
    } else if (distanceFt <= 6) {
        return { label: 'Good', color: '#8BC34A', icon: '‚úì', width: '2-3mm' };
    } else if (distanceFt <= 8) {
        return { label: 'Fair', color: '#FF9800', icon: '‚ö†Ô∏è', width: '3-4mm' };
    } else if (distanceFt <= 10) {
        return { label: 'Poor', color: '#FF5722', icon: '‚ö†Ô∏è', width: '4-5mm' };
    } else {
        return { label: 'Low', color: '#f44336', icon: '‚úó', width: '5mm+' };
    }
}

// Update from wall distance slider
function updateFromDistance() {
    var slider = document.getElementById('distanceSlider');
    var distanceFt = parseFloat(slider.value);
    
    segmentState.distance = distanceFt;
    segmentState.coverage = getCoverageFromDistance(distanceFt);
    
    document.getElementById('distanceValue').textContent = distanceFt + ' ft';
    
    updateCoverageDisplay();
    calculateSegments();
}

// Update from floor mode sliders
function updateFloorCoverage() {
    var heightSlider = document.getElementById('tripodHeightSlider');
    var distSlider = document.getElementById('floorDistanceSlider');
    
    var tripodHeight = parseFloat(heightSlider.value);
    var floorDist = parseFloat(distSlider.value);
    
    segmentState.tripodHeight = tripodHeight;
    segmentState.floorDistance = floorDist;
    segmentState.coverage = getFloorCoverage(tripodHeight, floorDist);
    
    document.getElementById('tripodHeightValue').textContent = tripodHeight + ' ft';
    document.getElementById('floorDistanceValue').textContent = floorDist + ' ft';
    
    updateCoverageDisplay();
    calculateSegments();
}

// Update coverage display
function updateCoverageDisplay() {
    var container = document.getElementById('coverageResult');
    if (!container) return;
    
    var coverage = segmentState.coverage;
    var quality;
    
    if (segmentState.surface === 'wall') {
        quality = getLineQuality(segmentState.distance);
    } else {
        var beamDist = getFloorBeamDistance(segmentState.tripodHeight, segmentState.floorDistance);
        quality = getLineQuality(beamDist);
    }
    
    var html = '<div class="grid-2">';

    // Coverage box
    html += '<div class="stat-box">';
    html += '<div class="stat-label">Coverage</div>';
    html += '<div class="stat-value">' + coverage + '"</div>';
    html += '<div class="stat-detail">(' + (coverage/12).toFixed(1) + ' ft)</div>';
    html += '</div>';

    // Quality box
    html += '<div class="stat-box">';
    html += '<div class="stat-label">Line Quality</div>';
    html += '<div class="stat-value" style="color:' + quality.color + ';">' + quality.icon + ' ' + quality.label + '</div>';
    html += '<div class="stat-detail">~' + quality.width + '</div>';
    html += '</div>';

    html += '</div>';
    
    container.innerHTML = html;
}

// Calculate segments needed based on wall size vs coverage
function calculateSegments() {
    var wallW = C.wall.tW;
    var wallH = C.wall.lH;
    var coverage = segmentState.coverage;
    
    // Apply 10% safety buffer - don't want pattern right at the edge
    var usableCoverage = coverage * 0.9;
    
    // No wall dimensions yet
    if (wallW <= 0 || wallH <= 0) {
        segmentState.enabled = false;
        segmentState.segments = [];
        updateProjectionModeUI();
        return;
    }
    
    var cols = Math.ceil(wallW / usableCoverage);
    var rows = Math.ceil(wallH / usableCoverage);
    var total = cols * rows;
    
    // If fits in one shot, no segments needed
    if (total <= 1) {
        segmentState.enabled = false;
        segmentState.segments = [];
        updateProjectionModeUI();
        return;
    }
    
    // Build segment array with path order based on mode
    segmentState.enabled = true;
    segmentState.segments = [];
    segmentState.currentSegment = 0;
    
    // Create all segments first
    var id = 0;
    for (var row = 0; row < rows; row++) {
        for (var col = 0; col < cols; col++) {
            segmentState.segments.push({
                id: id,
                row: row,
                col: col,
                x: col * usableCoverage,          // Position in inches
                y: row * usableCoverage,          // Position in inches  
                width: Math.min(usableCoverage, wallW - col * usableCoverage),
                height: Math.min(usableCoverage, wallH - row * usableCoverage),
                status: 'locked',
                pathOrder: -1,
                adjacent: { up: null, down: null, left: null, right: null }
            });
            id++;
        }
    }
    
    // Build adjacency graph
    for (var i = 0; i < segmentState.segments.length; i++) {
        var seg = segmentState.segments[i];
        var r = seg.row;
        var c = seg.col;
        
        seg.adjacent.up = findSegmentAt(r + 1, c, rows, cols);
        seg.adjacent.down = findSegmentAt(r - 1, c, rows, cols);
        seg.adjacent.left = findSegmentAt(r, c - 1, rows, cols);
        seg.adjacent.right = findSegmentAt(r, c + 1, rows, cols);
    }
    
    // Generate path order based on surface type
    if (segmentState.surface === 'floor') {
        // Floor mode: Serpentine starting from corner you're standing at (row 0)
        generateSerpentinePathOrder(rows, cols);
    } else {
        // Wall mode: Bottom-left first, work up (so you can see what you're doing)
        generateBottomUpPathOrder(rows, cols);
    }
    
    // Set first segment in path as ready
    var firstSegId = findSegmentByPathOrder(0);
    if (firstSegId !== null) {
        segmentState.segments[firstSegId].status = 'ready';
        segmentState.currentSegment = firstSegId;
    }
    
    updateProjectionModeUI();
    
    // Also update our global segments for draw() overlay
    segments = segmentState.segments;
    currentSegmentId = segmentState.currentSegment;
}

// Find segment at grid position
function findSegmentAt(row, col, maxRows, maxCols) {
    if (row < 0 || row >= maxRows || col < 0 || col >= maxCols) return null;
    return row * maxCols + col;
}

// Find segment by path order
function findSegmentByPathOrder(order) {
    for (var i = 0; i < segmentState.segments.length; i++) {
        if (segmentState.segments[i].pathOrder === order) {
            return i;
        }
    }
    return null;
}

// Serpentine path for floor tiling (start corner, zigzag across)
function generateSerpentinePathOrder(rows, cols) {
    var order = 0;
    
    for (var row = 0; row < rows; row++) {
        if (row % 2 === 0) {
            // Even rows: left to right
            for (var col = 0; col < cols; col++) {
                var idx = row * cols + col;
                segmentState.segments[idx].pathOrder = order++;
            }
        } else {
            // Odd rows: right to left
            for (var col = cols - 1; col >= 0; col--) {
                var idx = row * cols + col;
                segmentState.segments[idx].pathOrder = order++;
            }
        }
    }
}

// Bottom-up path for wall projection (bottom row first)
function generateBottomUpPathOrder(rows, cols) {
    var order = 0;
    
    // Bottom row first, then work up
    for (var row = 0; row < rows; row++) {
        for (var col = 0; col < cols; col++) {
            var idx = row * cols + col;
            segmentState.segments[idx].pathOrder = order++;
        }
    }
}

// Update the projection mode UI
function updateProjectionModeUI() {
    var fullWallMode = document.getElementById('fullWallMode');
    var segmentedMode = document.getElementById('segmentedMode');
    var noWallMode = document.getElementById('noWallMode');
    
    if (!fullWallMode || !segmentedMode || !noWallMode) return;
    
    // No wall dimensions
    if (C.wall.tW <= 0 || C.wall.lH <= 0) {
        fullWallMode.style.display = 'none';
        segmentedMode.style.display = 'none';
        noWallMode.style.display = 'block';
        return;
    }
    
    noWallMode.style.display = 'none';
    
    // Full wall mode
    if (!segmentState.enabled) {
        fullWallMode.style.display = 'block';
        segmentedMode.style.display = 'none';
        return;
    }
    
    // Segmented mode
    fullWallMode.style.display = 'none';
    segmentedMode.style.display = 'block';
    
    var usableCoverage = segmentState.coverage * 0.9;
    var cols = Math.ceil(C.wall.tW / usableCoverage);
    var rows = Math.ceil(C.wall.lH / usableCoverage);
    
    // Calculate progress
    var completed = segmentState.segments.filter(function(s) { return s.status === 'complete'; }).length;
    var total = segmentState.segments.length;
    var percent = Math.round(completed / total * 100);
    
    // Build segment grid header with progress
    var gridHtml = '<div class="mb-3">';
    gridHtml += '<div class="flex-between mb-2">';
    gridHtml += '<span class="text-sm text-muted">' + total + ' segments</span>';
    gridHtml += '<span class="text-bold" style="font-size:14px;color:' + (percent === 100 ? '#46a758' : '#f0a000') + ';">' + percent + '% complete</span>';
    gridHtml += '</div>';

    // Progress bar
    gridHtml += '<div class="progress-bar">';
    gridHtml += '<div class="progress-bar-fill" style="width:' + percent + '%;"></div>';
    gridHtml += '</div></div>';
    
    // Segment grid
    gridHtml += '<div style="display:grid;grid-template-columns:repeat(' + cols + ',1fr);gap:6px;max-width:260px;margin:0 auto;">';
    
    // For floor mode, render from top (far from user) to bottom (near user)
    // For wall mode, render from top to bottom visually (same as before)
    var isFloor = segmentState.surface === 'floor';
    
    for (var row = rows - 1; row >= 0; row--) {
        for (var col = 0; col < cols; col++) {
            var seg = segmentState.segments.find(function(s) {
                return s.row === row && s.col === col;
            });
            if (!seg) continue;
            
            var isCurrent = seg.id === segmentState.currentSegment;
            var isComplete = seg.status === 'complete';
            var isReady = seg.status === 'ready';
            var isNext = false;
            
            // Check if this is the recommended next segment
            if (!isCurrent && !isComplete) {
                var currentSeg = segmentState.segments[segmentState.currentSegment];
                if (currentSeg && seg.pathOrder === currentSeg.pathOrder + 1) {
                    isNext = true;
                }
            }
            
            var bg = '#1c2333', border = '#484f58', color = '#484f58', cursor = 'pointer';
            var content = String(seg.pathOrder + 1); // Show path order, not ID

            if (isComplete) {
                bg = 'rgba(70,167,88,0.12)'; border = '#46a758'; color = '#46a758'; content = '‚úì';
            } else if (isCurrent) {
                bg = 'rgba(229,72,77,0.12)'; border = '#e5484d'; color = '#e6edf3';
            } else if (isNext) {
                bg = 'rgba(240,160,0,0.12)'; border = '#f0a000'; color = '#f0a000';
            } else if (!isReady && !isComplete) {
                bg = '#0d1117'; border = 'rgba(240,246,252,0.08)'; color = '#484f58'; cursor = 'not-allowed';
            }
            
            gridHtml += '<div onclick="selectSegment(' + seg.id + ')" style="';
            gridHtml += 'background:' + bg + ';border:2px solid ' + border + ';border-radius:8px;';
            gridHtml += 'padding:10px 6px;text-align:center;cursor:' + cursor + ';';
            gridHtml += 'font-size:16px;font-weight:bold;color:' + color + ';';
            gridHtml += 'transition:all 0.2s;';
            gridHtml += '">' + content + '</div>';
        }
    }
    gridHtml += '</div>';
    
    // Path direction hint
    var pathHint = isFloor ? '‚Üî Serpentine: follow numbers' : '‚¨Ü Start bottom, work up';
    gridHtml += '<div class="hint mt-2">' + pathHint + '</div>';
    
    document.getElementById('segmentGrid').innerHTML = gridHtml;
    
    // Current segment info
    var current = segmentState.segments[segmentState.currentSegment];
    var label = getSegmentLabel(current);
    
    var infoHtml = '<div style="font-size:16px;font-weight:bold;color:var(--text-primary);">Segment ' + (current.pathOrder + 1) + ' of ' + total + '</div>';
    infoHtml += '<div class="text-sm text-muted">' + label + '</div>';
    
    // Show adjacent segments for floor mode
    if (isFloor && current.adjacent) {
        var adjLabels = [];
        if (current.adjacent.up !== null) adjLabels.push('‚Üë');
        if (current.adjacent.down !== null) adjLabels.push('‚Üì');
        if (current.adjacent.left !== null) adjLabels.push('‚Üê');
        if (current.adjacent.right !== null) adjLabels.push('‚Üí');
        if (adjLabels.length > 0) {
            infoHtml += '<div style="font-size:10px;color:#666;margin-top:4px;">Adjacent: ' + adjLabels.join(' ') + '</div>';
        }
    }
    
    document.getElementById('segmentInfo').innerHTML = infoHtml;
    
    // Update buttons
    var projectBtn = document.getElementById('projectSegmentBtn');
    var completeBtn = document.getElementById('markCompleteBtn');
    
    projectBtn.textContent = 'üî¥ Project Segment ' + (current.id + 1);
    completeBtn.style.display = current.status !== 'complete' ? 'block' : 'none';
    completeBtn.textContent = '‚úì Mark Segment ' + (current.id + 1) + ' Complete';
}

// Get human-readable segment label
function getSegmentLabel(segment) {
    var rows = Math.ceil(C.wall.lH / segmentState.coverage);
    var cols = Math.ceil(C.wall.tW / segmentState.coverage);
    
    var rowLabel = segment.row === 0 ? 'Bottom' : segment.row === rows - 1 ? 'Top' : 'Row ' + (segment.row + 1);
    var colLabel = segment.col === 0 ? 'Left' : segment.col === cols - 1 ? 'Right' : 'Col ' + (segment.col + 1);
    
    if (cols === 1) return rowLabel;
    if (rows === 1) return colLabel;
    return rowLabel + '-' + colLabel;
}

// Select a segment
function selectSegment(id) {
    var segment = segmentState.segments[id];
    if (!segment) return;
    
    // In floor mode, allow selecting adjacent segments or next in path
    var isFloor = segmentState.surface === 'floor';
    var current = segmentState.segments[segmentState.currentSegment];
    
    if (segment.status === 'locked') {
        // Check if this is an adjacent segment to current (more flexible navigation)
        var isAdjacent = false;
        if (current && current.adjacent) {
            isAdjacent = current.adjacent.up === id || 
                        current.adjacent.down === id || 
                        current.adjacent.left === id || 
                        current.adjacent.right === id;
        }
        
        if (isAdjacent && isFloor) {
            // Allow jumping to adjacent in floor mode
            segment.status = 'ready';
        } else {
            // Find which segment needs to be done first (by path order)
            var neededOrder = 0;
            for (var i = 0; i < segmentState.segments.length; i++) {
                var seg = segmentState.segments[i];
                if (seg.status !== 'complete' && seg.pathOrder < segment.pathOrder) {
                    neededOrder = seg.pathOrder + 1;
                    break;
                }
            }
            var hint = isFloor ? 'follow the serpentine path' : 'bottom to top';
            showToast('‚ö†Ô∏è Complete Segment ' + neededOrder + ' first (' + hint + ')', 2500);
            return;
        }
    }
    
    segmentState.currentSegment = id;
    currentSegmentId = id; // Update global for draw()
    updateProjectionModeUI();
    draw(); // Redraw to show segment highlight
}

// Mark current segment complete
function markSegmentComplete() {
    var current = segmentState.segments[segmentState.currentSegment];
    current.status = 'complete';
    
    // Find next segment by path order
    var nextPathOrder = current.pathOrder + 1;
    var nextSegment = null;
    
    for (var i = 0; i < segmentState.segments.length; i++) {
        if (segmentState.segments[i].pathOrder === nextPathOrder) {
            nextSegment = segmentState.segments[i];
            break;
        }
    }
    
    if (nextSegment) {
        nextSegment.status = 'ready';
        segmentState.currentSegment = nextSegment.id;
        currentSegmentId = nextSegment.id; // Update global for draw()
        
        // Show direction hint for floor mode
        var hint = '';
        if (segmentState.surface === 'floor') {
            var currentCol = current.col;
            var nextCol = nextSegment.col;
            if (nextSegment.row > current.row) hint = ' (move away from start)';
            else if (nextCol > currentCol) hint = ' (move right)';
            else if (nextCol < currentCol) hint = ' (move left)';
        }
        
        showToast('‚úÖ Done! Reposition laser for Segment ' + (nextSegment.pathOrder + 1) + hint, 3000);
    } else {
        // All complete!
        showToast('üéâ All segments complete! Floor is done!', 4000);
    }
    
    updateProjectionModeUI();
    autoSaveState();
    draw();
}

// Project full wall
function projectFullWall() {
    if (!laserConnected) {
        showToast('Connect to laser first, or use Export', 2000);
        return;
    }
    sendToLaser();
}

// Project current segment
function projectCurrentSegment() {
    var seg = segmentState.segments[segmentState.currentSegment];
    if (!seg) {
        showToast('No segment selected', 2000);
        return;
    }
    
    // Start projector mode focused on this segment
    startSegmentProjection(seg);
}

// Start projection mode focused on a specific segment
function startSegmentProjection(seg) {
    try {
        projMode = true;
        
        // Sync global segments array with segmentState
        segments = segmentState.segments;
        currentSegmentId = segmentState.currentSegment;
        
        // Hide tabs
        document.getElementById('tabBar').style.display = 'none';
        document.body.style.background = '#ffffff';
        
        // Remove any existing overlay
        var existing = document.getElementById('projOverlay');
        if (existing) existing.remove();
        
        // IMPORTANT: Hide ALL panels and force diagram to front
        var panels = document.querySelectorAll('.panel');
        panels.forEach(function(p) { 
            p.classList.remove('active');
            p.style.display = 'none';  // Force hide
        });
        var diagram = document.getElementById('diagram');
        diagram.classList.add('active');
        diagram.style.display = 'block';  // Force show
        
        // Make canvas container fullscreen FIRST
        var container = document.getElementById('canvasContainer');
        container.style.cssText = 'position:fixed !important;top:0 !important;left:0 !important;width:100vw !important;height:100vh !important;z-index:1000 !important;border-radius:0 !important;margin:0 !important;background:#fff !important;';
        
        // Calculate zoom to fit segment with some padding
        var viewW = window.innerWidth;
        var viewH = window.innerHeight;
        
        // Segment dimensions in inches
        var segW = seg.width || segmentConfig.width;
        var segH = seg.height || segmentConfig.height;
        
        // Calculate zoom to fit segment (with 10% padding)
        var zoomX = (viewW * 0.8) / segW;
        var zoomY = (viewH * 0.8) / segH;
        var targetZoom = Math.min(zoomX, zoomY);
        
        // Set zoom
        C.view.z = targetZoom;
        
        // Calculate pan to center the segment
        var segCenterX = seg.x + segW / 2;
        var segCenterY = seg.y + segH / 2;
        
        // Pan so segment center is at screen center
        C.view.panX = (viewW / 2) - (segCenterX * targetZoom) - 40; // 40 is baseOx
        C.view.panY = (viewH / 2) - (segCenterY * targetZoom) - 40; // 40 is baseOy
        
        // Build overlay UI
        var overlay = document.createElement('div');
        overlay.id = 'projOverlay';
        overlay.innerHTML =
            // Top bar with segment info
            '<div class="proj-top-bar">' +
                '<div>' +
                    '<div style="font-size:18px;font-weight:bold;color:#fff;">Segment ' + (seg.pathOrder + 1) + '</div>' +
                    '<div style="font-size:12px;color:#8b949e;">Row ' + (seg.row + 1) + ', Col ' + (seg.col + 1) + '</div>' +
                '</div>' +
                '<div style="display:flex;gap:10px;align-items:center;">' +
                    '<div id="segmentCutBadge" style="background:#8b949e;color:#fff;padding:6px 12px;border-radius:20px;font-size:14px;font-weight:bold;">...</div>' +
                '</div>' +
            '</div>' +

            // Bottom controls
            '<div class="proj-bottom-bar">' +
                '<button class="proj-btn" onclick="prevSegment()" title="Previous">‚óÄ</button>' +
                '<button onclick="markSegmentCompleteFromProj()" style="background:linear-gradient(135deg,#46a758,#3a8f4a);color:#fff;border:none;padding:15px 30px;border-radius:10px;font-size:16px;font-weight:bold;cursor:pointer;box-shadow:0 0 20px rgba(70,167,88,0.3);">‚úì Done</button>' +
                '<button class="proj-btn" onclick="nextSegment()" title="Next">‚ñ∂</button>' +
                '<button onclick="exitProj()" style="background:#cc0000;color:#fff;border:none;padding:15px 20px;border-radius:10px;font-size:18px;margin-left:20px;cursor:pointer;">‚úï</button>' +
            '</div>' +

            // Segment navigation hint
            '<div style="position:fixed;bottom:90px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);color:#e6edf3;padding:8px 16px;border-radius:8px;font-size:12px;z-index:1003;border:1px solid rgba(255,255,255,0.06);">' +
                'Tap cut tiles for measurements ‚Ä¢ ‚óÄ‚ñ∂ to navigate ‚Ä¢ ‚úì when done' +
            '</div>';
            
        document.body.appendChild(overlay);
        
        // Enable cut tile tapping in projector mode for this segment
        window.segmentProjMode = true;
        window.currentProjSegment = seg;
        
        // Draw first, then update cut count
        setTimeout(function() {
            draw();
            // Update cut count after draw populates cutTilesData
            updateSegmentCutCount(seg);
        }, 100);
        
        showToast('Segment ' + (seg.pathOrder + 1) + ' - Tap tiles for cut details', 2500);
        
    } catch(err) {
        console.error('Projection error:', err);
        showToast('Error: ' + err.message, 3000);
    }
}

// Update cut count display after draw
function updateSegmentCutCount(seg) {
    var count = 0;
    
    // Get scale and offset
    var s = C.view.z;
    var baseOx = 40;
    var baseOy = 40;
    var panX = C.view.panX || 0;
    var panY = C.view.panY || 0;
    
    // Segment bounds in pixels with buffer for edge tiles
    var buffer = C.tile.w * s; // One tile width as buffer
    var segLeftPx = baseOx + panX + seg.x * s - buffer;
    var segRightPx = baseOx + panX + (seg.x + (seg.width || 36)) * s + buffer;
    var segTopPx = baseOy + panY + seg.y * s - buffer;
    var segBottomPx = baseOy + panY + (seg.y + (seg.height || 36)) * s + buffer;
    
    // Count cut tiles within segment that are not yet marked as done
    for (var i = 0; i < cutTilesData.length; i++) {
        var tile = cutTilesData[i];
        
        // tile.x and tile.y are the tile position in pixels
        if (tile.x >= segLeftPx && tile.x < segRightPx &&
            tile.y >= segTopPx && tile.y < segBottomPx) {
            
            var state = cutTileStates[tile.key] || 0;
            if (state !== 2) { // Not yet marked as cut
                count++;
            }
        }
    }
    
    // Find and update the badge
    var badge = document.getElementById('segmentCutBadge');
    if (badge) {
        if (count > 0) {
            badge.style.background = '#e5484d';
            badge.textContent = count + ' cut' + (count > 1 ? 's' : '');
        } else {
            badge.style.background = '#46a758';
            badge.textContent = 'All done!';
        }
    }
}

// Navigate to previous segment
function prevSegment() {
    var current = segmentState.segments[segmentState.currentSegment];
    if (!current) return;
    
    var prevOrder = current.pathOrder - 1;
    if (prevOrder < 0) {
        showToast('This is the first segment', 1500);
        return;
    }
    
    // Find segment with previous path order
    for (var i = 0; i < segmentState.segments.length; i++) {
        if (segmentState.segments[i].pathOrder === prevOrder) {
            segmentState.currentSegment = i;
            currentSegmentId = i;
            startSegmentProjection(segmentState.segments[i]);
            return;
        }
    }
}

// Navigate to next segment
function nextSegment() {
    var current = segmentState.segments[segmentState.currentSegment];
    if (!current) return;
    
    var nextOrder = current.pathOrder + 1;
    if (nextOrder >= segmentState.segments.length) {
        showToast('This is the last segment', 1500);
        return;
    }
    
    // Find segment with next path order
    for (var i = 0; i < segmentState.segments.length; i++) {
        if (segmentState.segments[i].pathOrder === nextOrder) {
            segmentState.currentSegment = i;
            currentSegmentId = i;
            
            // Unlock if needed
            if (segmentState.segments[i].status === 'locked') {
                segmentState.segments[i].status = 'ready';
            }
            
            startSegmentProjection(segmentState.segments[i]);
            return;
        }
    }
}

// Mark complete from projection mode
function markSegmentCompleteFromProj() {
    markSegmentComplete();
    
    // Check if there's a next segment
    var current = segmentState.segments[segmentState.currentSegment];
    if (current && current.status !== 'complete') {
        // Move to next segment in projection
        startSegmentProjection(current);
    } else {
        // All done - exit projection
        showToast('üéâ All segments complete!', 3000);
        setTimeout(exitProj, 2000);
    }
}

// Initialize on page load
function initLaserTab() {
    updateFromDistance();
}

// ==================== END SEGMENT SYSTEM ====================

// ==================== MEASUREMENT WIZARD ====================

var wizState = {
    surface: 'wall',    // 'wall' or 'floor'
    shape: 'rectangle', // 'rectangle' or 'custom'
    format: 'inches',   // 'inches' or 'feet'
    currentStep: 1
};

function showWizard() {
    document.getElementById('measureWizard').classList.remove('hidden');
    wizState.currentStep = 1;
    wizShowStep(1);
    // Reset selections
    wizState.surface = 'wall';
    wizState.shape = 'rectangle';
    wizState.format = 'inches';
}

function closeWizard() {
    document.getElementById('measureWizard').classList.add('hidden');
}

function wizShowStep(step) {
    wizState.currentStep = step;
    // Hide all steps
    for (var i = 1; i <= 3; i++) {
        var stepEl = document.getElementById('wizStep' + i);
        var actEl = document.getElementById('wizActions' + i);
        if (stepEl) stepEl.style.display = 'none';
        if (actEl) actEl.style.display = 'none';
    }
    // Show current step
    var s = document.getElementById('wizStep' + step);
    var a = document.getElementById('wizActions' + step);
    if (s) s.style.display = '';
    if (a) a.style.display = '';
    // Update progress dots
    var dots = document.querySelectorAll('.wiz-progress-dot');
    dots.forEach(function(dot, i) {
        dot.className = 'wiz-progress-dot';
        if (i < step - 1) dot.classList.add('filled');
        else if (i === step - 1) { dot.classList.add('filled'); dot.classList.add('current'); }
    });
}

function wizSelectSurface(type, el) {
    wizState.surface = type;
    var cards = document.querySelectorAll('#wizSurfaceCards .wiz-method-card');
    cards.forEach(function(c) { c.classList.remove('selected'); });
    el.classList.add('selected');
}

function wizSelectShape(type, el) {
    wizState.shape = type;
    var cards = document.querySelectorAll('#wizShapeCards .wiz-method-card');
    cards.forEach(function(c) { c.classList.remove('selected'); });
    el.classList.add('selected');
}

function wizSetFormat(fmt, el) {
    wizState.format = fmt;
    var btns = document.querySelectorAll('#wizFormatBtns .wiz-format-btn');
    btns.forEach(function(b) { b.classList.remove('active'); });
    el.classList.add('active');
    document.getElementById('wizInchInputs').style.display = (fmt === 'inches') ? '' : 'none';
    document.getElementById('wizFeetInputs').style.display = (fmt === 'feet') ? '' : 'none';
}

function wizNext(fromStep) {
    if (fromStep === 1) {
        if (wizState.shape === 'rectangle') {
            // Update visual label for surface type
            var title = document.getElementById('wizMeasureTitle');
            if (wizState.surface === 'floor') {
                title.textContent = 'Measure Your Floor Area';
            } else {
                title.textContent = 'Grab Your Tape Measure';
            }
            wizShowStep(2);
            // Focus first input after transition
            setTimeout(function() {
                var inp = document.getElementById('wizWidth');
                if (inp) inp.focus();
            }, 300);
        } else {
            // Custom shape ‚Üí show drawing instructions
            wizShowStep(3);
        }
    }
}

function wizBack(fromStep) {
    if (fromStep === 2 || fromStep === 3) {
        wizShowStep(1);
    }
}

function wizGetDimensions() {
    var w = 0, h = 0;
    if (wizState.format === 'inches') {
        w = parseFloat(document.getElementById('wizWidth').value) || 0;
        h = parseFloat(document.getElementById('wizHeight').value) || 0;
    } else {
        var wFt = parseFloat(document.getElementById('wizWidthFt').value) || 0;
        var wIn = parseFloat(document.getElementById('wizWidthIn').value) || 0;
        var hFt = parseFloat(document.getElementById('wizHeightFt').value) || 0;
        var hIn = parseFloat(document.getElementById('wizHeightIn').value) || 0;
        w = (wFt * 12) + wIn;
        h = (hFt * 12) + hIn;
    }
    return { width: w, height: h };
}

function wizApply() {
    var dims = wizGetDimensions();
    if (dims.width <= 0 || dims.height <= 0) {
        showToast('Please enter both width and height');
        return;
    }

    // Set perimeter mode
    setPerimeterMode(wizState.surface);

    // Apply as quick rectangle
    var widthEl = document.getElementById('quickWidth');
    var heightEl = document.getElementById('quickHeight');
    if (widthEl) widthEl.value = dims.width;
    if (heightEl) heightEl.value = dims.height;
    applyQuickRectangle();

    // Close wizard
    closeWizard();

    // Navigate to tile settings with a slight delay so the user sees the result
    setTimeout(function() {
        showToast('Wall set to ' + dims.width + '" x ' + dims.height + '" ‚Äî now pick your tile!');
        showTab('tile');
    }, 400);
}

function wizGoToDrawing() {
    // Set surface mode
    setPerimeterMode(wizState.surface);
    // Close wizard and show wall tab with drawing tools
    closeWizard();
    showTab('wall');
    showToast('Tap the corners of your ' + wizState.surface + ' to draw the outline');
}

// Override startNewProject to show wizard
var _originalStartNewProject = null;

function patchStartNewProject() {
    if (typeof startNewProject === 'function' && !_originalStartNewProject) {
        _originalStartNewProject = startNewProject;
        startNewProject = function() {
            _originalStartNewProject();
            // Show wizard instead of just dumping user on wall tab
            setTimeout(function() { showWizard(); }, 100);
        };
    }
}

// Also add a "Measure Wall" button trigger on the wall tab
function addWizardButton() {
    var wallPanel = document.getElementById('wall');
    if (!wallPanel) return;
    var firstSection = wallPanel.querySelector('.section');
    if (!firstSection) return;

    var btn = document.createElement('button');
    btn.className = 'btn-primary';
    btn.style.cssText = 'width:100%;padding:14px;font-size:14px;font-weight:600;margin-bottom:16px;background:linear-gradient(135deg,#22c55e,#16a34a);border:none;color:#fff;border-radius:14px;cursor:pointer;box-shadow:0 0 20px rgba(34,197,94,0.25);';
    btn.innerHTML = 'üìê Guided Setup ‚Äî Measure Your Space';
    btn.onclick = function() { showWizard(); };
    wallPanel.insertBefore(btn, firstSection);
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(function() {
        patchStartNewProject();
        addWizardButton();
    }, 500);
});

// ==================== PERIMETER DRAWING SYSTEM ====================

var perimeterState = {
    mode: 'wall',           // 'wall' or 'floor'
    points: [],             // Array of {x, y} in canvas coordinates
    closed: false,          // Is the shape closed?
    segments: [],           // Array of {p1, p2, length, measured} after closing
    selectedSegment: null,  // Currently selected segment index
    scale: 1,               // Pixels per inch (calculated after dimensions entered)
    canvas: null,
    ctx: null
};

// Initialize perimeter canvas
function initPerimeterCanvas() {
    perimeterState.canvas = document.getElementById('perimeterCanvas');
    if (!perimeterState.canvas) return;
    
    perimeterState.ctx = perimeterState.canvas.getContext('2d');
    
    // Set up touch/click handlers
    perimeterState.canvas.addEventListener('click', handlePerimeterClick);
    perimeterState.canvas.addEventListener('touchend', handlePerimeterTouch);
    
    drawPerimeter();
}

// Set perimeter mode (wall or floor)
function setPerimeterMode(mode) {
    perimeterState.mode = mode;
    
    var wallBtn = document.getElementById('perimWallBtn');
    var floorBtn = document.getElementById('perimFloorBtn');
    
    if (mode === 'wall') {
        wallBtn.className = 'btn-primary';
        floorBtn.className = 'btn-secondary';
    } else {
        wallBtn.className = 'btn-secondary';
        floorBtn.className = 'btn-primary';
    }
    
    // Also sync with laser tab
    if (typeof setProjectionSurface === 'function') {
        setProjectionSurface(mode);
    }
}

// Handle click on perimeter canvas
function handlePerimeterClick(e) {
    if (perimeterState.closed) {
        // Check if clicking on a segment
        handleSegmentClick(e);
        return;
    }
    
    var rect = perimeterState.canvas.getBoundingClientRect();
    var x = e.clientX - rect.left;
    var y = e.clientY - rect.top;
    
    // Scale for actual canvas size
    var scaleX = perimeterState.canvas.width / rect.width;
    var scaleY = perimeterState.canvas.height / rect.height;
    x *= scaleX;
    y *= scaleY;
    
    addPerimeterPoint(x, y);
}

// Handle touch on perimeter canvas
function handlePerimeterTouch(e) {
    e.preventDefault();
    if (e.changedTouches.length > 0) {
        var touch = e.changedTouches[0];
        var rect = perimeterState.canvas.getBoundingClientRect();
        var x = touch.clientX - rect.left;
        var y = touch.clientY - rect.top;
        
        var scaleX = perimeterState.canvas.width / rect.width;
        var scaleY = perimeterState.canvas.height / rect.height;
        x *= scaleX;
        y *= scaleY;
        
        if (perimeterState.closed) {
            handleSegmentClickAt(x, y);
        } else {
            addPerimeterPoint(x, y);
        }
    }
}

// Add a point to the perimeter
function addPerimeterPoint(x, y) {
    // Check if closing the shape (clicking near first point)
    if (perimeterState.points.length >= 3) {
        var first = perimeterState.points[0];
        var dist = Math.sqrt((x - first.x) ** 2 + (y - first.y) ** 2);
        if (dist < 20) {
            closePerimeter();
            return;
        }
    }
    
    perimeterState.points.push({ x: x, y: y });
    
    updatePerimeterUI();
    drawPerimeter();
}

// Undo last point
function undoPerimeterPoint() {
    if (perimeterState.points.length > 0) {
        perimeterState.points.pop();
        updatePerimeterUI();
        drawPerimeter();
    }
}

// Clear all points
function clearPerimeter() {
    perimeterState.points = [];
    perimeterState.closed = false;
    perimeterState.segments = [];
    perimeterState.selectedSegment = null;
    perimeterState.measurementHistory = [];
    
    document.getElementById('segmentMeasurements').style.display = 'none';
    document.getElementById('perimeterHint').style.display = 'block';
    
    updatePerimeterUI();
    drawPerimeter();
}

// Close the perimeter shape
function closePerimeter() {
    if (perimeterState.points.length < 3) {
        showToast('Need at least 3 points to close shape');
        return;
    }
    
    perimeterState.closed = true;
    
    // Create segments from points
    perimeterState.segments = [];
    for (var i = 0; i < perimeterState.points.length; i++) {
        var p1 = perimeterState.points[i];
        var p2 = perimeterState.points[(i + 1) % perimeterState.points.length];
        perimeterState.segments.push({
            p1: p1,
            p2: p2,
            length: null,   // To be entered by user
            measured: false
        });
    }
    
    document.getElementById('perimeterHint').style.display = 'none';
    document.getElementById('segmentMeasurements').style.display = 'block';
    
    updatePerimeterUI();
    updateSegmentsList();
    drawPerimeter();
    
    showToast('Shape closed! Now enter measurements for each wall segment.');
}

// Update UI elements
function updatePerimeterUI() {
    var pointCount = perimeterState.points.length;
    var status = document.getElementById('perimeterStatus');
    var undoBtn = document.getElementById('undoBtn');
    var closeBtn = document.getElementById('closeBtn');
    
    if (perimeterState.closed) {
        var measured = perimeterState.segments.filter(function(s) { return s.measured; }).length;
        status.textContent = 'Shape closed | ' + measured + ' of ' + perimeterState.segments.length + ' segments measured';
    } else {
        status.textContent = 'Points: ' + pointCount + ' | ' + (pointCount < 3 ? 'Add more points' : 'Tap first point or Close to finish');
    }
    
    undoBtn.disabled = pointCount === 0 || perimeterState.closed;
    closeBtn.disabled = pointCount < 3 || perimeterState.closed;
}

// Draw the perimeter on canvas
function drawPerimeter() {
    var canvas = perimeterState.canvas;
    var ctx = perimeterState.ctx;
    if (!canvas || !ctx) return;
    
    // Clear
    ctx.fillStyle = '#0a0a15';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    ctx.strokeStyle = '#1a1a2e';
    ctx.lineWidth = 1;
    for (var x = 0; x < canvas.width; x += 20) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (var y = 0; y < canvas.height; y += 20) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
    
    var points = perimeterState.points;
    if (points.length === 0) return;
    
    // Draw segments
    ctx.lineWidth = 3;
    for (var i = 0; i < points.length; i++) {
        var p1 = points[i];
        var p2 = points[(i + 1) % points.length];
        
        // Don't draw last segment if not closed
        if (!perimeterState.closed && i === points.length - 1) continue;
        
        // Color based on whether measured
        var seg = perimeterState.segments[i];
        if (seg && seg.measured) {
            ctx.strokeStyle = '#4CAF50';
        } else if (perimeterState.selectedSegment === i) {
            ctx.strokeStyle = '#e94560';
        } else {
            ctx.strokeStyle = '#FF9800';
        }
        
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        
        // Draw measurement label if measured
        if (seg && seg.measured && seg.length) {
            var midX = (p1.x + p2.x) / 2;
            var midY = (p1.y + p2.y) / 2;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(seg.length + '"', midX, midY - 8);
        }
    }
    
    // Draw points
    for (var i = 0; i < points.length; i++) {
        var p = points[i];
        
        ctx.beginPath();
        ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = i === 0 ? '#e94560' : '#4CAF50';
        ctx.fill();
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Point number
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 10px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(i + 1), p.x, p.y);
    }
}

// Update the segments list UI
function updateSegmentsList() {
    var container = document.getElementById('wallSegmentsList');
    if (!container) return;
    
    var html = '';
    perimeterState.segments.forEach(function(seg, i) {
        var dirLabel = getSegmentDirection(seg);
        var measured = seg.measured && seg.length;

        var bgColor = measured ? 'rgba(70,167,88,0.12)' : (perimeterState.selectedSegment === i ? 'rgba(229,72,77,0.12)' : 'var(--bg-recessed)');
        var borderColor = measured ? '#46a758' : (perimeterState.selectedSegment === i ? '#e5484d' : 'rgba(240,246,252,0.12)');

        html += '<div onclick="selectSegment(' + i + ')" style="';
        html += 'display:flex;align-items:center;gap:12px;padding:12px;margin-bottom:8px;';
        html += 'background:' + bgColor + ';';
        html += 'border:2px solid ' + borderColor + ';';
        html += 'border-radius:10px;cursor:pointer;transition:all 0.15s ease;">';

        html += '<div style="width:30px;height:30px;background:var(--bg-elevated);border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:var(--text-primary);font-size:13px;flex-shrink:0;">' + (i + 1) + '</div>';

        html += '<div style="flex:1;">';
        html += '<div style="font-size:13px;color:var(--text-primary);">Wall ' + (i + 1) + ' <span style="color:var(--text-tertiary);">(' + dirLabel + ')</span></div>';
        html += '</div>';

        if (measured) {
            html += '<div style="font-size:18px;font-weight:bold;color:#46a758;">' + seg.length + '"</div>';
            html += '<button onclick="event.stopPropagation();undoMeasurement(' + i + ')" style="background:var(--bg-elevated);color:var(--text-secondary);border:1px solid rgba(240,246,252,0.08);border-radius:6px;padding:4px 8px;font-size:11px;cursor:pointer;">‚úèÔ∏è</button>';
        } else {
            html += '<input type="number" id="segInput' + i + '" placeholder="inches" style="width:70px;padding:8px;font-size:14px;" onclick="event.stopPropagation()" onchange="setSegmentLength(' + i + ', this.value)">';
        }

        html += '</div>';
    });
    
    container.innerHTML = html;
    
    // Update measured count
    var measured = perimeterState.segments.filter(function(s) { return s.measured; }).length;
    document.getElementById('measuredCount').textContent = measured + ' / ' + perimeterState.segments.length;
    document.getElementById('applyPerimBtn').disabled = measured < perimeterState.segments.length;
    var undoMeasureBtn = document.getElementById('undoMeasureBtn');
    if (undoMeasureBtn) undoMeasureBtn.disabled = measured === 0;
}

// Get direction label for a segment
function getSegmentDirection(seg) {
    var dx = seg.p2.x - seg.p1.x;
    var dy = seg.p2.y - seg.p1.y;
    var angle = Math.atan2(dy, dx) * 180 / Math.PI;
    
    if (angle > -45 && angle <= 45) return '‚Üí';
    if (angle > 45 && angle <= 135) return '‚Üì';
    if (angle > 135 || angle <= -135) return '‚Üê';
    return '‚Üë';
}

// Select a segment for editing
function selectSegment(index) {
    perimeterState.selectedSegment = index;
    updateSegmentsList();
    drawPerimeter();
    
    // Focus the input
    var input = document.getElementById('segInput' + index);
    if (input) {
        setTimeout(function() { input.focus(); }, 100);
    }
}

// Handle click on segment in canvas
function handleSegmentClickAt(x, y) {
    // Find closest segment
    var minDist = Infinity;
    var closestIdx = -1;
    
    perimeterState.segments.forEach(function(seg, i) {
        var dist = pointToSegmentDistance(x, y, seg.p1, seg.p2);
        if (dist < minDist && dist < 20) {
            minDist = dist;
            closestIdx = i;
        }
    });
    
    if (closestIdx >= 0) {
        selectSegment(closestIdx);
    }
}

// Calculate distance from point to line segment
function pointToSegmentDistance(px, py, p1, p2) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    var len2 = dx * dx + dy * dy;
    
    if (len2 === 0) return Math.sqrt((px - p1.x) ** 2 + (py - p1.y) ** 2);
    
    var t = Math.max(0, Math.min(1, ((px - p1.x) * dx + (py - p1.y) * dy) / len2));
    var projX = p1.x + t * dx;
    var projY = p1.y + t * dy;
    
    return Math.sqrt((px - projX) ** 2 + (py - projY) ** 2);
}

// Undo a specific segment measurement
function undoMeasurement(index) {
    perimeterState.segments[index].length = null;
    perimeterState.segments[index].measured = false;
    perimeterState.selectedSegment = index;
    perimeterState.measurementHistory = (perimeterState.measurementHistory || []).filter(function(i) { return i !== index; });
    updateSegmentsList();
    updatePerimeterUI();
    drawPerimeter();
    // Focus the input
    setTimeout(function() {
        var input = document.getElementById('segInput' + index);
        if (input) input.focus();
    }, 100);
}

// Undo the last entered measurement
function undoLastMeasurement() {
    var history = perimeterState.measurementHistory || [];
    if (history.length === 0) return;
    var lastIndex = history.pop();
    undoMeasurement(lastIndex);
}

// Set segment length
function setSegmentLength(index, value) {
    var length = parseFloat(value);
    if (isNaN(length) || length <= 0) {
        showToast('Enter a valid length in inches');
        return;
    }
    
    perimeterState.segments[index].length = length;
    perimeterState.segments[index].measured = true;
    if (!perimeterState.measurementHistory) perimeterState.measurementHistory = [];
    perimeterState.measurementHistory.push(index);
    
    // Move to next unmeasured segment
    var nextUnmeasured = perimeterState.segments.findIndex(function(s, i) {
        return i > index && !s.measured;
    });
    if (nextUnmeasured === -1) {
        nextUnmeasured = perimeterState.segments.findIndex(function(s) {
            return !s.measured;
        });
    }
    
    if (nextUnmeasured >= 0) {
        perimeterState.selectedSegment = nextUnmeasured;
    } else {
        perimeterState.selectedSegment = null;
    }
    
    updateSegmentsList();
    updatePerimeterUI();
    drawPerimeter();
}

// Apply the perimeter dimensions
function applyPerimeter() {
    // Calculate the scale and generate the wall polygon
    var segments = perimeterState.segments;
    
    // Check all segments are measured
    var allMeasured = segments.every(function(s) { return s.measured && s.length > 0; });
    if (!allMeasured) {
        showToast('Please measure all wall segments first');
        return;
    }
    
    // Build the polygon with real dimensions
    // The canvas Y is inverted (down = positive), but we want Y to go up for tile layout
    // So we'll build it in canvas orientation first, then flip
    
    var polygon = [{ x: 0, y: 0 }];
    var current = { x: 0, y: 0 };
    
    // Process all segments to build the shape
    for (var i = 0; i < segments.length; i++) {
        var seg = segments[i];
        var dx = seg.p2.x - seg.p1.x;
        var dy = seg.p2.y - seg.p1.y;
        var canvasLen = Math.sqrt(dx * dx + dy * dy);
        
        if (canvasLen === 0) continue;
        
        // Normalize direction and apply real length
        var realLen = seg.length;
        current = {
            x: current.x + (dx / canvasLen) * realLen,
            y: current.y + (dy / canvasLen) * realLen
        };
        
        // Don't add the last point (it should close back to origin)
        if (i < segments.length - 1) {
            polygon.push({ x: current.x, y: current.y });
        }
    }
    
    // Calculate bounding box
    var minX = Math.min.apply(null, polygon.map(function(p) { return p.x; }));
    var maxX = Math.max.apply(null, polygon.map(function(p) { return p.x; }));
    var minY = Math.min.apply(null, polygon.map(function(p) { return p.y; }));
    var maxY = Math.max.apply(null, polygon.map(function(p) { return p.y; }));
    
    var width = maxX - minX;
    var height = maxY - minY;
    
    // Shift polygon so min corner is at origin, and flip Y so bottom = 0
    polygon.forEach(function(p) {
        p.x = p.x - minX;
        p.y = height - (p.y - minY); // Flip Y
    });
    
    // Store the polygon
    C.polygon = polygon;
    
    // Update legacy wall dimensions (for backward compatibility)
    C.wall.tW = width;
    C.wall.lH = height;
    C.wall.rV = 0;
    C.wall.bV = 0;
    
    markUnsaved();
    calculateSegments();
    draw();
    
    showToast('‚úì Perimeter applied! Go to üìê Diagram to see layout.', 3000);
    showTab('diagram');
}

// Quick rectangle mode
function applyQuickRectangle() {
    var width = parseFloat(document.getElementById('quickWidth').value);
    var height = parseFloat(document.getElementById('quickHeight').value);
    
    if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
        showToast('Enter valid width and height');
        return;
    }
    
    // Clear any drawn perimeter
    clearPerimeter();
    
    // Set simple rectangle polygon
    C.polygon = [
        { x: 0, y: 0 },
        { x: width, y: 0 },
        { x: width, y: height },
        { x: 0, y: height }
    ];
    
    // Update legacy dimensions
    C.wall.tW = width;
    C.wall.lH = height;
    C.wall.rV = 0;
    C.wall.bV = 0;
    
    markUnsaved();
    calculateSegments();
    draw();
    
    showToast('‚úì Rectangle applied!', 2000);
    showTab('diagram');
}

// Initialize perimeter canvas on load
setTimeout(initPerimeterCanvas, 100);

// ==================== END PERIMETER SYSTEM ====================

function setSection(sec) {
    projSection = sec;
}

function updateSectionButtons() {
    // Legacy function - no longer used
}

// Legacy projector functions - kept as stubs for compatibility
function updateProjSetup() {
    // Removed - projector mode replaced with laser export
}

function startCalibration() {
    // Removed - use startLaserCalibration instead
    showToast('Use Laser Calibration instead');
}

function drawCalibration() {
    var container = document.getElementById('canvasContainer');
    cv.width = window.innerWidth * 2;
    cv.height = window.innerHeight * 2;
    
    cx.setTransform(1, 0, 0, 1, 0, 0);
    cx.scale(2, 2);
    
    // White background
    cx.fillStyle = '#ffffff';
    cx.fillRect(0, 0, cv.width, cv.height);
    
    var centerX = cv.width / 4;
    var centerY = cv.height / 4 - 50;
    
    // Draw 12" calibration line
    // At correct scale, this should be 12 inches when projected
    var s = C.view.z; // Use current zoom as scale reference
    var lineLength = 12 * s; // 12 inches at current scale
    
    cx.strokeStyle = '#000000';
    cx.lineWidth = 4;
    cx.beginPath();
    cx.moveTo(centerX - lineLength, centerY);
    cx.lineTo(centerX + lineLength, centerY);
    cx.stroke();
    
    // Draw end markers
    cx.beginPath();
    cx.moveTo(centerX - lineLength, centerY - 20);
    cx.lineTo(centerX - lineLength, centerY + 20);
    cx.moveTo(centerX + lineLength, centerY - 20);
    cx.lineTo(centerX + lineLength, centerY + 20);
    cx.stroke();
    
    // Label
    cx.fillStyle = '#000000';
    cx.font = 'bold 24px sans-serif';
    cx.textAlign = 'center';
    cx.fillText('‚Üê 12 INCHES ‚Üí', centerX, centerY - 40);
    
    // Zoom hint
    cx.font = '16px sans-serif';
    cx.fillText('Current app zoom: ' + C.view.z + 'x', centerX, centerY + 60);
    cx.fillText('Adjust projector distance/zoom until line = 12"', centerX, centerY + 90);
}

function confirmCalibration() {
    calibrationMode = false;
    alert('‚úÖ Calibration saved!\n\nYour projector is now set to display actual-size patterns.\n\nLaunch the projector to see your tile layout!');
    exitProj();
}

// Initialize setup calculator
setTimeout(updateProjSetup, 100);
let C = {
    wall: { lH: 70, rV: 0.5, tW: 58, bV: 0.25 },
    tile: { sh: 'herringbone', or: 'pointy', w: 2, h: 4, gr: 0.125, pattern: 0 },
    voids: [{ l: 'Niche', x: 27.75, y: 37, w: 13.25, h: 12 }],
    view: { z: 5, ox: 0, oy: 0 }
};

let drag = { on: false, sx: 0, sy: 0, dx: 0, dy: 0 };
let full = 0, part = 0, projMode = false;

// ============================================
// SEGMENT SYSTEM - for projector navigation
// ============================================
var segmentConfig = {
    width: 36,   // Segment width in inches (3 feet)
    height: 36,  // Segment height in inches (3 feet)
    overlap: 2   // Overlap in inches for alignment reference
};

var segments = [];          // Array of segment objects
var currentSegmentId = null; // Currently active segment
var segmentPath = [];       // Optimal traversal order
var completedSegments = []; // IDs of completed segments

// Segment object structure:
// {
//   id: number,
//   row: number,
//   col: number,
//   x: number (inches from origin),
//   y: number (inches from origin),
//   width: number (inches),
//   height: number (inches),
//   status: 'pending' | 'current' | 'complete',
//   adjacent: { up: id|null, down: id|null, left: id|null, right: id|null },
//   pathOrder: number (position in optimal traversal),
//   edgeSignature: { top: [...], bottom: [...], left: [...], right: [...] }
// }

// Generate segments for the current floor layout
function generateSegments() {
    segments = [];
    segmentPath = [];
    completedSegments = [];
    currentSegmentId = null;
    
    // Get floor dimensions
    var floorW = Math.max(C.wall.tW, C.wall.tW + C.wall.bV);
    var floorH = Math.max(C.wall.lH, C.wall.lH + C.wall.rV);
    
    // Calculate grid dimensions
    var segW = segmentConfig.width;
    var segH = segmentConfig.height;
    var cols = Math.ceil(floorW / segW);
    var rows = Math.ceil(floorH / segH);
    
    // Generate segment grid
    var id = 0;
    for (var row = 0; row < rows; row++) {
        for (var col = 0; col < cols; col++) {
            var seg = {
                id: id,
                row: row,
                col: col,
                x: col * segW,
                y: row * segH,
                width: Math.min(segW, floorW - col * segW),
                height: Math.min(segH, floorH - row * segH),
                status: 'pending',
                adjacent: {
                    up: null,
                    down: null,
                    left: null,
                    right: null
                },
                pathOrder: -1,
                edgeSignature: null
            };
            segments.push(seg);
            id++;
        }
    }
    
    // Build adjacency graph
    for (var i = 0; i < segments.length; i++) {
        var seg = segments[i];
        var r = seg.row;
        var c = seg.col;
        
        // Find adjacent segments
        seg.adjacent.up = findSegmentByRowCol(r - 1, c);
        seg.adjacent.down = findSegmentByRowCol(r + 1, c);
        seg.adjacent.left = findSegmentByRowCol(r, c - 1);
        seg.adjacent.right = findSegmentByRowCol(r, c + 1);
    }
    
    // Generate optimal path (serpentine from top-left)
    generateSerpentinePath(rows, cols);
    
    // Set first segment as current
    if (segmentPath.length > 0) {
        currentSegmentId = segmentPath[0];
        segments[currentSegmentId].status = 'current';
    }
    
    console.log('Generated ' + segments.length + ' segments (' + cols + ' cols x ' + rows + ' rows)');
    return segments;
}

// Find segment by row/col
function findSegmentByRowCol(row, col) {
    for (var i = 0; i < segments.length; i++) {
        if (segments[i].row === row && segments[i].col === col) {
            return segments[i].id;
        }
    }
    return null;
}

// Generate serpentine path starting from top-left corner
function generateSerpentinePath(rows, cols) {
    segmentPath = [];
    var order = 0;
    
    for (var row = 0; row < rows; row++) {
        if (row % 2 === 0) {
            // Even rows: left to right
            for (var col = 0; col < cols; col++) {
                var segId = findSegmentByRowCol(row, col);
                if (segId !== null) {
                    segmentPath.push(segId);
                    segments[segId].pathOrder = order++;
                }
            }
        } else {
            // Odd rows: right to left
            for (var col = cols - 1; col >= 0; col--) {
                var segId = findSegmentByRowCol(row, col);
                if (segId !== null) {
                    segmentPath.push(segId);
                    segments[segId].pathOrder = order++;
                }
            }
        }
    }
}

// Get next recommended segment
function getNextSegment() {
    if (currentSegmentId === null) return segmentPath[0] || null;
    
    var currentOrder = segments[currentSegmentId].pathOrder;
    
    // Find next uncompleted segment in path order
    for (var i = currentOrder + 1; i < segmentPath.length; i++) {
        var segId = segmentPath[i];
        if (segments[segId].status !== 'complete') {
            return segId;
        }
    }
    
    // All done!
    return null;
}

// Get valid next segments (adjacent and not complete)
function getValidNextSegments() {
    if (currentSegmentId === null) return [segmentPath[0]];
    
    var current = segments[currentSegmentId];
    var valid = [];
    
    // Check all adjacent segments
    ['up', 'down', 'left', 'right'].forEach(function(dir) {
        var adjId = current.adjacent[dir];
        if (adjId !== null && segments[adjId].status !== 'complete') {
            valid.push(adjId);
        }
    });
    
    return valid;
}

// Mark current segment as complete and move to next
function completeCurrentSegment() {
    if (currentSegmentId === null) return;
    
    segments[currentSegmentId].status = 'complete';
    completedSegments.push(currentSegmentId);
    
    var nextId = getNextSegment();
    if (nextId !== null) {
        currentSegmentId = nextId;
        segments[nextId].status = 'current';
    } else {
        currentSegmentId = null;
        console.log('All segments complete!');
    }
    
    saveData();
    draw();
}

// Navigate to specific segment
function goToSegment(segId) {
    if (segId < 0 || segId >= segments.length) return;
    
    // Mark previous current as pending (unless complete)
    if (currentSegmentId !== null && segments[currentSegmentId].status === 'current') {
        segments[currentSegmentId].status = 'pending';
    }
    
    currentSegmentId = segId;
    if (segments[segId].status !== 'complete') {
        segments[segId].status = 'current';
    }
    
    // Pan view to center on this segment
    var seg = segments[segId];
    C.view.panX = -(seg.x + seg.width/2) * C.view.z + window.innerWidth / 2;
    C.view.panY = -(seg.y + seg.height/2) * C.view.z + window.innerHeight / 2;
    
    draw();
}

// Get segment progress stats
function getSegmentProgress() {
    return {
        total: segments.length,
        completed: completedSegments.length,
        remaining: segments.length - completedSegments.length,
        percent: segments.length > 0 ? Math.round(completedSegments.length / segments.length * 100) : 0
    };
}

// ============================================
// END SEGMENT SYSTEM
// ============================================

// Track cut tile states: 0=orange(pending), 1=yellow(selected), 2=red(cut)
var cutTileStates = {};
var cutTilesData = []; // Store cut tile info for tap detection
var cutDoneCount = 0;

const cv = document.getElementById('canvas');
const cx = cv.getContext('2d');

// Generate unique key for a tile based on position
function tileKey(row, col) {
    return row + ',' + col;
}

// Handle tap on canvas to cycle cut tile state
var pendingUncutKey = null;
var detailTileData = null; // Store tile data for detail view

function handleCanvasTap(e) {
    // Allow tapping in segment projection mode, but not regular projector mode
    if (projMode && !window.segmentProjMode) return;
    
    // Only allow cut tile interactions when pattern is locked (or in segment projection)
    if (!patternLocked && !window.segmentProjMode) {
        // Show a hint to lock the pattern first
        showLockHint();
        return;
    }
    
    var rect = cv.getBoundingClientRect();
    var scaleX = cv.width / rect.width;
    var scaleY = cv.height / rect.height;
    var tapX = (e.clientX - rect.left) * scaleX / 2; // Divide by 2 for retina scale
    var tapY = (e.clientY - rect.top) * scaleY / 2;
    
    // Check if tap is on any cut tile
    for (var i = 0; i < cutTilesData.length; i++) {
        var tile = cutTilesData[i];
        if (isPointInTile(tapX, tapY, tile.x, tile.y, tile.tw, tile.th, tile.verts)) {
            var key = tile.key;
            var currentState = cutTileStates[key] || 0;
            
            // If tile is red (state 2), show confirmation modal
            if (currentState === 2) {
                pendingUncutKey = key;
                document.getElementById('uncutModal').classList.add('active');
                return;
            }
            
            // If tile is orange (state 0), show detail view and mark yellow
            if (currentState === 0) {
                cutTileStates[key] = 1; // Mark as yellow/selected
                detailTileData = tile; // Store for detail view
                showDetailView(tile);
                // Defer canvas redraw so the detail overlay paints immediately
                setTimeout(function() { draw(); }, 50);
                return;
            }
            
            // If tile is yellow (state 1), mark as red/cut
            if (currentState === 1) {
                cutTileStates[key] = 2;
                draw();
                return;
            }
            
            return;
        }
    }
}

function showLockHint() {
    // Brief visual hint to lock the pattern first
    var lockBtn = document.getElementById('lockBtn');
    var originalBg = lockBtn.style.background;
    
    // Flash the lock button
    lockBtn.style.background = '#f0a000';
    lockBtn.style.transform = 'scale(1.05)';
    
    setTimeout(function() {
        lockBtn.style.background = originalBg;
        lockBtn.style.transform = 'scale(1)';
    }, 300);
    
    // Also show a brief tooltip message
    var hint = document.createElement('div');
    hint.textContent = 'üîí Lock pattern first to mark tiles';
    hint.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);color:#fff;padding:15px 25px;border-radius:8px;font-size:14px;z-index:9999;text-align:center;';
    document.body.appendChild(hint);
    
    setTimeout(function() {
        hint.remove();
    }, 1500);
}

function closeUncutModal(confirmed) {
    document.getElementById('uncutModal').classList.remove('active');
    
    if (confirmed && pendingUncutKey) {
        cutTileStates[pendingUncutKey] = 0; // Reset to orange
        draw();
    }
    pendingUncutKey = null;
}

// ============ TILE DETAIL VIEW ============

// Detail view zoom/pan state
var detailZoom = 1;
var detailPanX = 0;
var detailPanY = 0;
var detailTouchStartDist = 0;
var detailTouchStartZoom = 1;
var detailLastTouchX = 0;
var detailLastTouchY = 0;
var detailIsPanning = false;
var detailPinchCenterX = 0;
var detailPinchCenterY = 0;
var detailStartPanX = 0;
var detailStartPanY = 0;

function showDetailView(tile) {
    // Reset zoom/pan for new tile
    detailZoom = 1;
    detailPanX = 0;
    detailPanY = 0;
    
    // Store tile data for redrawing on zoom
    window.currentDetailTile = tile;
    
    // Draw the detail
    drawDetailView();
    
    // Show overlay
    document.getElementById('detailOverlay').classList.add('active');
    
    // Set up touch handlers
    setupDetailTouchHandlers();
}

function setupDetailTouchHandlers() {
    var canvas = document.getElementById('detailCanvas');
    
    canvas.ontouchstart = function(e) {
        e.preventDefault();
        if (e.touches.length === 2) {
            // Pinch start
            var dx = e.touches[0].clientX - e.touches[1].clientX;
            var dy = e.touches[0].clientY - e.touches[1].clientY;
            detailTouchStartDist = Math.sqrt(dx * dx + dy * dy);
            detailTouchStartZoom = detailZoom;
            // Store pinch center
            detailPinchCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            detailPinchCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            // Store current pan
            detailStartPanX = detailPanX;
            detailStartPanY = detailPanY;
        } else if (e.touches.length === 1) {
            // Pan start
            detailLastTouchX = e.touches[0].clientX;
            detailLastTouchY = e.touches[0].clientY;
            detailIsPanning = true;
        }
    };
    
    canvas.ontouchmove = function(e) {
        e.preventDefault();
        if (e.touches.length === 2) {
            // Pinch zoom - zoom towards pinch center
            var dx = e.touches[0].clientX - e.touches[1].clientX;
            var dy = e.touches[0].clientY - e.touches[1].clientY;
            var dist = Math.sqrt(dx * dx + dy * dy);
            var scaleChange = dist / detailTouchStartDist;
            var newZoom = Math.max(0.5, Math.min(5, detailTouchStartZoom * scaleChange));
            
            // Get current pinch center
            var rect = canvas.getBoundingClientRect();
            var currentCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
            var currentCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
            
            // Calculate the point that should stay fixed (the original pinch center)
            // Convert to world coordinates using start zoom and pan
            var startPinchX = detailPinchCenterX - rect.left;
            var startPinchY = detailPinchCenterY - rect.top;
            
            var size = 400;
            var worldX = (startPinchX - detailStartPanX - size/2) / detailTouchStartZoom + size/2;
            var worldY = (startPinchY - detailStartPanY - size/2) / detailTouchStartZoom + size/2;
            
            // Calculate new pan to keep that world point under the current pinch center
            detailPanX = currentCenterX - size/2 - (worldX - size/2) * newZoom;
            detailPanY = currentCenterY - size/2 - (worldY - size/2) * newZoom;
            
            detailZoom = newZoom;
            drawDetailView();
        } else if (e.touches.length === 1 && detailIsPanning) {
            // Pan
            var dx = e.touches[0].clientX - detailLastTouchX;
            var dy = e.touches[0].clientY - detailLastTouchY;
            detailPanX += dx;
            detailPanY += dy;
            detailLastTouchX = e.touches[0].clientX;
            detailLastTouchY = e.touches[0].clientY;
            drawDetailView();
        }
    };
    
    canvas.ontouchend = function(e) {
        detailIsPanning = false;
    };
    
    // Mouse wheel zoom for desktop - zoom towards cursor
    canvas.onwheel = function(e) {
        e.preventDefault();
        var rect = canvas.getBoundingClientRect();
        var cx = e.clientX - rect.left;
        var cy = e.clientY - rect.top;
        
        var oldZoom = detailZoom;
        var delta = e.deltaY > 0 ? 0.9 : 1.1;
        var newZoom = Math.max(0.5, Math.min(5, detailZoom * delta));
        
        // Convert cursor position to world coordinates
        var size = 400;
        var worldX = (cx - detailPanX - size/2) / oldZoom + size/2;
        var worldY = (cy - detailPanY - size/2) / oldZoom + size/2;
        
        // Calculate new pan to keep that world point under the cursor
        detailPanX = cx - size/2 - (worldX - size/2) * newZoom;
        detailPanY = cy - size/2 - (worldY - size/2) * newZoom;
        
        detailZoom = newZoom;
        drawDetailView();
    };
    
    // Mouse drag for desktop
    canvas.onmousedown = function(e) {
        detailLastTouchX = e.clientX;
        detailLastTouchY = e.clientY;
        detailIsPanning = true;
    };
    
    canvas.onmousemove = function(e) {
        if (detailIsPanning) {
            var dx = e.clientX - detailLastTouchX;
            var dy = e.clientY - detailLastTouchY;
            detailPanX += dx;
            detailPanY += dy;
            detailLastTouchX = e.clientX;
            detailLastTouchY = e.clientY;
            drawDetailView();
        }
    };
    
    canvas.onmouseup = function() {
        detailIsPanning = false;
    };
    
    canvas.onmouseleave = function() {
        detailIsPanning = false;
    };
}

function drawDetailView() {
    var tile = window.currentDetailTile;
    if (!tile) return;
    
    var canvas = document.getElementById('detailCanvas');
    var ctx = canvas.getContext('2d');
    
    // Larger canvas size for better detail
    var size = 400;
    canvas.width = size * 2; // Retina
    canvas.height = size * 2;
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(2, 2);
    
    // Clear canvas
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, size, size);
    
    // Apply zoom and pan - zoom from center, then apply pan
    ctx.save();
    ctx.translate(detailPanX, detailPanY);
    ctx.translate(size / 2, size / 2);
    ctx.scale(detailZoom, detailZoom);
    ctx.translate(-size / 2, -size / 2);
    
    var scale = tile.scale;
    var tileCenterX = tile.x;
    var tileCenterY = tile.y;
    
    // Get full tile vertices in inches
    var tileVertsInches = [];
    for (var i = 0; i < tile.verts.length; i++) {
        tileVertsInches.push([
            (tile.verts[i][0] - tileCenterX) / scale,
            (tile.verts[i][1] - tileCenterY) / scale
        ]);
    }
    
    // Get tile bounding box
    var tileMinX = tileVertsInches[0][0], tileMaxX = tileVertsInches[0][0];
    var tileMinY = tileVertsInches[0][1], tileMaxY = tileVertsInches[0][1];
    for (var i = 1; i < tileVertsInches.length; i++) {
        tileMinX = Math.min(tileMinX, tileVertsInches[i][0]);
        tileMaxX = Math.max(tileMaxX, tileVertsInches[i][0]);
        tileMinY = Math.min(tileMinY, tileVertsInches[i][1]);
        tileMaxY = Math.max(tileMaxY, tileVertsInches[i][1]);
    }
    
    var tileW = tileMaxX - tileMinX;
    var tileH = tileMaxY - tileMinY;
    
    // Calculate cuts needed
    var cuts = [];
    
    // Check wall cuts - find how much is outside the wall on each side
    var wallCutLeft = 0, wallCutRight = 0, wallCutTop = 0, wallCutBottom = 0;
    
    // Get wall intersections to find actual cut amounts
    for (var i = 0; i < tile.verts.length; i++) {
        var v1 = tile.verts[i];
        var v2 = tile.verts[(i + 1) % tile.verts.length];
        
        // Check if this edge crosses the wall
        for (var j = 0; j < tile.wall.length; j++) {
            var w1 = tile.wall[j];
            var w2 = tile.wall[(j + 1) % tile.wall.length];
            var inter = lineIntersect(v1, v2, w1, w2);
            if (inter) {
                var ix = (inter[0] - tileCenterX) / scale;
                var iy = (inter[1] - tileCenterY) / scale;
                
                // Determine which side this intersection is on
                if (Math.abs(ix - tileMinX) < 0.5) {
                    wallCutLeft = Math.max(wallCutLeft, Math.abs(tileMinX - ix));
                }
                if (Math.abs(ix - tileMaxX) < 0.5) {
                    wallCutRight = Math.max(wallCutRight, Math.abs(tileMaxX - ix));
                }
            }
        }
    }
    
    // Check which vertices are outside wall and calculate cut from edge
    for (var i = 0; i < tile.verts.length; i++) {
        if (!inPoly(tile.verts[i], tile.wall)) {
            var vx = (tile.verts[i][0] - tileCenterX) / scale;
            var vy = (tile.verts[i][1] - tileCenterY) / scale;
            
            // Find distance from tile edge to where cut happens
            if (vx <= tileMinX + 0.1) wallCutLeft = Math.max(wallCutLeft, tileW);
            if (vx >= tileMaxX - 0.1) wallCutRight = Math.max(wallCutRight, tileW);
            if (vy <= tileMinY + 0.1) wallCutTop = Math.max(wallCutTop, tileH);
            if (vy >= tileMaxY - 0.1) wallCutBottom = Math.max(wallCutBottom, tileH);
        }
    }
    
    // Calculate the remaining piece dimensions after wall cuts
    var pieceW = tileW;
    var pieceH = tileH;
    var isCutByVertexCount = false;
    
    // Get cut points to find actual remaining dimensions
    var voidPolysArray = tile.voidPolys || [];
    var cutPoints = getCutPoints(tile.verts, tile.wall, voidPolysArray);
    if (cutPoints.length >= 3) {
        var cpMinX = Infinity, cpMaxX = -Infinity;
        var cpMinY = Infinity, cpMaxY = -Infinity;
        for (var i = 0; i < cutPoints.length; i++) {
            var cx = (cutPoints[i][0] - tileCenterX) / scale;
            var cy = (cutPoints[i][1] - tileCenterY) / scale;
            cpMinX = Math.min(cpMinX, cx);
            cpMaxX = Math.max(cpMaxX, cx);
            cpMinY = Math.min(cpMinY, cy);
            cpMaxY = Math.max(cpMaxY, cy);
        }
        pieceW = cpMaxX - cpMinX;
        pieceH = cpMaxY - cpMinY;
        
        // If the number of cut points differs from tile vertices, it's definitely cut
        if (cutPoints.length !== tile.verts.length) {
            isCutByVertexCount = true;
        }
    }
    
    // Check void notch
    var voidNotch = null;
    if (tile.voidPolys && tile.voidPolys.length > 0) {
        for (var vi = 0; vi < tile.voidPolys.length; vi++) {
            var voidPoly = tile.voidPolys[vi];
            
            // Get void bounds in tile-relative inches
            var vMinX = Infinity, vMaxX = -Infinity;
            var vMinY = Infinity, vMaxY = -Infinity;
            for (var i = 0; i < voidPoly.length; i++) {
                var vx = (voidPoly[i][0] - tileCenterX) / scale;
                var vy = (voidPoly[i][1] - tileCenterY) / scale;
                vMinX = Math.min(vMinX, vx);
                vMaxX = Math.max(vMaxX, vx);
                vMinY = Math.min(vMinY, vy);
                vMaxY = Math.max(vMaxY, vy);
            }
            
            // Check overlap with tile
            if (vMaxX > tileMinX && vMinX < tileMaxX && vMaxY > tileMinY && vMinY < tileMaxY) {
                // Calculate notch (intersection of void with tile)
                var notchL = Math.max(vMinX, tileMinX);
                var notchR = Math.min(vMaxX, tileMaxX);
                var notchT = Math.max(vMinY, tileMinY);
                var notchB = Math.min(vMaxY, tileMaxY);
                
                var notchW = notchR - notchL;
                var notchH = notchB - notchT;
                
                if (notchW > 0.1 && notchH > 0.1) {
                    // Determine corner
                    var corner = '';
                    if (notchL <= tileMinX + 0.1 && notchT <= tileMinY + 0.1) corner = 'top-left';
                    else if (notchR >= tileMaxX - 0.1 && notchT <= tileMinY + 0.1) corner = 'top-right';
                    else if (notchL <= tileMinX + 0.1 && notchB >= tileMaxY - 0.1) corner = 'bottom-left';
                    else if (notchR >= tileMaxX - 0.1 && notchB >= tileMaxY - 0.1) corner = 'bottom-right';
                    else corner = 'interior';
                    
                    voidNotch = { w: notchW, h: notchH, corner: corner };
                }
            }
        }
    }
    
    // Check if tile is fully inside wall (only void cuts, no wall cuts)
    var allVertsInWall = true;
    for (var i = 0; i < tile.verts.length; i++) {
        if (!inPoly(tile.verts[i], tile.wall)) { allVertsInWall = false; break; }
    }

    // Collect ALL void overlaps with this tile
    var voidOverlaps = [];
    if (tile.voidPolys && tile.voidPolys.length > 0) {
        for (var vi = 0; vi < tile.voidPolys.length; vi++) {
            var voidPoly = tile.voidPolys[vi];
            var vMinX = Infinity, vMaxX = -Infinity, vMinY = Infinity, vMaxY = -Infinity;
            for (var i = 0; i < voidPoly.length; i++) {
                var vx = (voidPoly[i][0] - tileCenterX) / scale;
                var vy = (voidPoly[i][1] - tileCenterY) / scale;
                vMinX = Math.min(vMinX, vx); vMaxX = Math.max(vMaxX, vx);
                vMinY = Math.min(vMinY, vy); vMaxY = Math.max(vMaxY, vy);
            }
            // Intersection of void bounds with tile bounds
            var oL = Math.max(vMinX, tileMinX), oR = Math.min(vMaxX, tileMaxX);
            var oT = Math.max(vMinY, tileMinY), oB = Math.min(vMaxY, tileMaxY);
            if (oR - oL > 0.1 && oB - oT > 0.1) {
                // Determine corner position
                var corner = '';
                if (oL <= tileMinX + 0.1 && oT <= tileMinY + 0.1) corner = 'top-left';
                else if (oR >= tileMaxX - 0.1 && oT <= tileMinY + 0.1) corner = 'top-right';
                else if (oL <= tileMinX + 0.1 && oB >= tileMaxY - 0.1) corner = 'bottom-left';
                else if (oR >= tileMaxX - 0.1 && oB >= tileMaxY - 0.1) corner = 'bottom-right';
                else corner = 'interior';
                voidOverlaps.push({ l: oL, r: oR, t: oT, b: oB, w: oR - oL, h: oB - oT, corner: corner });
            }
        }
    }

    // Now draw the detail view
    ctx.fillStyle = '#333';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'center';

    // Different display based on cut type
    var isVoidOnlyCut = allVertsInWall && voidOverlaps.length > 0;
    var isSimpleVoidNotch = voidNotch && voidNotch.corner !== 'interior';
    if (isVoidOnlyCut) {
        // VOID-ONLY CUT ‚Äî full tile with void overlaps shaded
        // Header text
        if (voidOverlaps.length === 1 && voidOverlaps[0].corner !== 'interior') {
            ctx.fillText('Cut notch from ' + voidOverlaps[0].corner + ':', size / 2, 35);
            ctx.fillStyle = '#4CAF50';
            ctx.font = 'bold 32px sans-serif';
            ctx.fillText(toFraction(voidOverlaps[0].w) + ' √ó ' + toFraction(voidOverlaps[0].h), size / 2, 80);
        } else {
            ctx.fillText('Mark and cut:', size / 2, 35);
            ctx.fillStyle = '#4CAF50';
            ctx.font = 'bold 20px sans-serif';
            var notchStrs = [];
            for (var i = 0; i < voidOverlaps.length; i++) {
                notchStrs.push(toFraction(voidOverlaps[i].w) + ' √ó ' + toFraction(voidOverlaps[i].h) + ' (' + voidOverlaps[i].corner + ')');
            }
            var headerY2 = 70;
            for (var i = 0; i < notchStrs.length; i++) {
                ctx.fillText(notchStrs[i], size / 2, headerY2);
                headerY2 += 24;
            }
        }

        var drawScale = Math.min(150 / tileW, 150 / tileH);
        var cx2 = size / 2;
        var cy2 = size / 2 + 40;

        // Full tile as solid yellow
        ctx.fillStyle = '#FFEB3B';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (var i = 0; i < tileVertsInches.length; i++) {
            var px = cx2 + tileVertsInches[i][0] * drawScale;
            var py = cy2 + tileVertsInches[i][1] * drawScale;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Shade each void overlap and draw cut lines
        for (var oi = 0; oi < voidOverlaps.length; oi++) {
            var vo = voidOverlaps[oi];
            var nl = cx2 + vo.l * drawScale;
            var nr = cx2 + vo.r * drawScale;
            var nt = cy2 + vo.t * drawScale;
            var nb = cy2 + vo.b * drawScale;

            // Gray offcut overlay
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(nl, nt, nr - nl, nb - nt);

            // Red dashed cut lines (interior L-shape edges only)
            ctx.strokeStyle = '#f44336';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            if (vo.corner === 'top-left') {
                ctx.moveTo(nl, nb); ctx.lineTo(nr, nb); ctx.lineTo(nr, nt);
            } else if (vo.corner === 'top-right') {
                ctx.moveTo(nr, nb); ctx.lineTo(nl, nb); ctx.lineTo(nl, nt);
            } else if (vo.corner === 'bottom-left') {
                ctx.moveTo(nl, nt); ctx.lineTo(nr, nt); ctx.lineTo(nr, nb);
            } else if (vo.corner === 'bottom-right') {
                ctx.moveTo(nr, nt); ctx.lineTo(nl, nt); ctx.lineTo(nl, nb);
            } else {
                // Interior void - draw full rectangle
                ctx.rect(nl, nt, nr - nl, nb - nt);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Dimension labels on cut lines
            ctx.fillStyle = '#f44336';
            ctx.font = 'bold 13px sans-serif';
            ctx.textAlign = 'center';
            var labelOffset = 18;
            // Width label
            ctx.fillText(toFraction(vo.w), (nl + nr) / 2, vo.corner.indexOf('bottom') >= 0 ? nt - labelOffset + 5 : nb + labelOffset);
            // Height label
            ctx.save();
            var hLabelX = vo.corner.indexOf('left') >= 0 ? nr + labelOffset : nl - labelOffset;
            ctx.translate(hLabelX, (nt + nb) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(toFraction(vo.h), 0, 0);
            ctx.restore();

            // Position labels (distance from tile edges to void)
            ctx.fillStyle = '#2E7D32';
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            var distFromLeft = vo.l - tileMinX;
            var distFromRight = tileMaxX - vo.r;
            var distFromTop = vo.t - tileMinY;
            var distFromBottom = tileMaxY - vo.b;
            if (distFromLeft > 0.1 && vo.corner.indexOf('left') < 0) {
                ctx.fillText(toFraction(distFromLeft) + '" from left', size / 2, cy2 + tileMaxY * drawScale + 30);
            }
            if (distFromRight > 0.1 && vo.corner.indexOf('right') < 0) {
                ctx.fillText(toFraction(distFromRight) + '" from right', size / 2, cy2 + tileMaxY * drawScale + 44);
            }
            if (distFromBottom > 0.1 && vo.corner.indexOf('bottom') < 0) {
                ctx.fillText(toFraction(distFromBottom) + '" from bottom', size / 2, cy2 + tileMaxY * drawScale + 58);
            }
        }

        // Tile size label
        ctx.fillStyle = '#999';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Tile size: ' + toFraction(tileW) + ' √ó ' + toFraction(tileH), size / 2, cy2 + tileMaxY * drawScale + 75);

    } else if (isSimpleVoidNotch) {
        // SIMPLE VOID NOTCH CUT ‚Äî clean L-shape display
        ctx.fillText('Cut notch from ' + voidNotch.corner + ':', size / 2, 35);

        // Big notch dimensions
        ctx.fillStyle = '#4CAF50';
        ctx.font = 'bold 32px sans-serif';
        ctx.fillText(toFraction(voidNotch.w) + ' √ó ' + toFraction(voidNotch.h), size / 2, 80);

        // Draw tile with notch visualization
        var drawScale = Math.min(150 / tileW, 150 / tileH);
        var cx = size / 2;
        var cy = size / 2 + 40;

        // Full tile outline (SOLID yellow)
        ctx.strokeStyle = '#333';
        ctx.fillStyle = '#FFEB3B';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (var i = 0; i < tileVertsInches.length; i++) {
            var px = cx + tileVertsInches[i][0] * drawScale;
            var py = cy + tileVertsInches[i][1] * drawScale;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Notch rectangle ‚Äî draw as gray offcut area
        var nl, nr, nt, nb;
        if (voidNotch.corner === 'top-left') {
            nl = cx + tileMinX * drawScale; nt = cy + tileMinY * drawScale;
        } else if (voidNotch.corner === 'top-right') {
            nl = cx + (tileMaxX - voidNotch.w) * drawScale; nt = cy + tileMinY * drawScale;
        } else if (voidNotch.corner === 'bottom-left') {
            nl = cx + tileMinX * drawScale; nt = cy + (tileMaxY - voidNotch.h) * drawScale;
        } else {
            nl = cx + (tileMaxX - voidNotch.w) * drawScale; nt = cy + (tileMaxY - voidNotch.h) * drawScale;
        }
        nr = nl + voidNotch.w * drawScale;
        nb = nt + voidNotch.h * drawScale;

        // Gray offcut overlay on notch area
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(nl, nt, nr - nl, nb - nt);

        // Red dashed cut lines (interior L-shape edges only)
        ctx.strokeStyle = '#f44336';
        ctx.lineWidth = 3;
        ctx.setLineDash([8, 4]);
        ctx.beginPath();
        if (voidNotch.corner === 'top-left') {
            ctx.moveTo(nl, nb); ctx.lineTo(nr, nb); ctx.lineTo(nr, nt);
        } else if (voidNotch.corner === 'top-right') {
            ctx.moveTo(nr, nb); ctx.lineTo(nl, nb); ctx.lineTo(nl, nt);
        } else if (voidNotch.corner === 'bottom-left') {
            ctx.moveTo(nl, nt); ctx.lineTo(nr, nt); ctx.lineTo(nr, nb);
        } else {
            ctx.moveTo(nr, nt); ctx.lineTo(nl, nt); ctx.lineTo(nl, nb);
        }
        ctx.stroke();
        ctx.setLineDash([]);

        // Dimension labels on cut lines
        ctx.fillStyle = '#f44336';
        ctx.font = 'bold 13px sans-serif';
        var labelOffset = 18;
        if (voidNotch.corner === 'top-left') {
            ctx.fillText(toFraction(voidNotch.w), (nl + nr) / 2, nb + labelOffset);
            ctx.save(); ctx.translate(nr + labelOffset, (nt + nb) / 2); ctx.rotate(-Math.PI / 2);
            ctx.fillText(toFraction(voidNotch.h), 0, 0); ctx.restore();
        } else if (voidNotch.corner === 'top-right') {
            ctx.fillText(toFraction(voidNotch.w), (nl + nr) / 2, nb + labelOffset);
            ctx.save(); ctx.translate(nl - labelOffset, (nt + nb) / 2); ctx.rotate(-Math.PI / 2);
            ctx.fillText(toFraction(voidNotch.h), 0, 0); ctx.restore();
        } else if (voidNotch.corner === 'bottom-left') {
            ctx.fillText(toFraction(voidNotch.w), (nl + nr) / 2, nt - labelOffset + 5);
            ctx.save(); ctx.translate(nr + labelOffset, (nt + nb) / 2); ctx.rotate(-Math.PI / 2);
            ctx.fillText(toFraction(voidNotch.h), 0, 0); ctx.restore();
        } else {
            ctx.fillText(toFraction(voidNotch.w), (nl + nr) / 2, nt - labelOffset + 5);
            ctx.save(); ctx.translate(nl - labelOffset, (nt + nb) / 2); ctx.rotate(-Math.PI / 2);
            ctx.fillText(toFraction(voidNotch.h), 0, 0); ctx.restore();
        }

    } else if (pieceW < tileW - 0.1 || pieceH < tileH - 0.1 || isCutByVertexCount || voidNotch) {
        // EDGE CUT - tile is cut by wall edge
        // Show tile in un-rotated (flat) orientation for practical cutting
        try {

        var voidPolysArray = tile.voidPolys || [];
        var cutPoints = getCutPoints(tile.verts, tile.wall, voidPolysArray);

        // Determine tile rotation angle for un-rotating
        var tileAngle = 0;
        var actualW = tile.tw / scale; // actual tile width in inches
        var actualH = tile.th / scale; // actual tile height in inches
        var shortSide = Math.min(actualW, actualH);
        var longSide = Math.max(actualW, actualH);

        if (tile.shape === 'herringbone') {
            tileAngle = (tile.col % 2 === 0) ? 45 : -45;
            if (tile.orient === 'flat') tileAngle = -tileAngle;
        }
        var rad = -tileAngle * Math.PI / 180; // negative to un-rotate
        var cosA = Math.cos(rad);
        var sinA = Math.sin(rad);

        // Un-rotate function: transform from world-relative to tile-local coords
        function unrotate(px, py) {
            // px,py are relative to tile center in inches
            return {
                x: px * cosA - py * sinA,
                y: px * sinA + py * cosA
            };
        }

        // Get cut points in un-rotated tile-local inches
        var cutPointsLocal = [];
        for (var i = 0; i < cutPoints.length; i++) {
            var rx = (cutPoints[i][0] - tileCenterX) / scale;
            var ry = (cutPoints[i][1] - tileCenterY) / scale;
            cutPointsLocal.push(unrotate(rx, ry));
        }

        // Don't re-sort ‚Äî getCutPoints already returns properly ordered polygon via edge-walking

        // Un-rotate tile vertices too
        var tileVertsLocal = [];
        for (var i = 0; i < tileVertsInches.length; i++) {
            tileVertsLocal.push(unrotate(tileVertsInches[i][0], tileVertsInches[i][1]));
        }

        // Use cutPointsLocal as the working data for the rest of this section
        var cutPointsInches = cutPointsLocal;
        
        // Find cut marks: for each tile edge, find all cut polygon points on it
        // that are NOT tile corners. Each such point needs a measurement from the
        // nearest tile corner that's part of the kept piece.
        var cutMarks = [];
        for (var j = 0; j < tileVertsLocal.length; j++) {
            var e1 = tileVertsLocal[j];
            var e2 = tileVertsLocal[(j + 1) % tileVertsLocal.length];
            var edgeLen = Math.sqrt((e2.x - e1.x) * (e2.x - e1.x) + (e2.y - e1.y) * (e2.y - e1.y));

            // Find all cut polygon points on this tile edge that aren't tile corners
            for (var i = 0; i < cutPointsInches.length; i++) {
                var p = cutPointsInches[i];

                // No corner skipping ‚Äî always show marks so user knows where every cut point lands

                if (isPointOnSegment(p.x, p.y, e1.x, e1.y, e2.x, e2.y, 0.3)) {
                    var distFromE1 = Math.sqrt((p.x - e1.x) * (p.x - e1.x) + (p.y - e1.y) * (p.y - e1.y));
                    var distFromE2 = Math.sqrt((p.x - e2.x) * (p.x - e2.x) + (p.y - e2.y) * (p.y - e2.y));

                    // Determine which corner is on the KEPT piece (in the cut polygon)
                    var e1OnKept = false, e2OnKept = false;
                    for (var k = 0; k < cutPointsInches.length; k++) {
                        if (Math.abs(cutPointsInches[k].x - e1.x) < 0.15 && Math.abs(cutPointsInches[k].y - e1.y) < 0.15) e1OnKept = true;
                        if (Math.abs(cutPointsInches[k].x - e2.x) < 0.15 && Math.abs(cutPointsInches[k].y - e2.y) < 0.15) e2OnKept = true;
                    }

                    // Skip if there's already a mark very close on the same edge (avoid duplicates like 1/8" and 3-7/8" on same edge)
                    var isDupe = false;
                    for (var d = 0; d < cutMarks.length; d++) {
                        if (cutMarks[d].edgeIndex === j) {
                            var dd = Math.sqrt((cutMarks[d].point.x - p.x)*(cutMarks[d].point.x - p.x) + (cutMarks[d].point.y - p.y)*(cutMarks[d].point.y - p.y));
                            if (dd < 0.5) { isDupe = true; break; }
                        }
                    }
                    if (isDupe) continue;

                    cutMarks.push({
                        point: p,
                        corner1: e1,
                        corner2: e2,
                        distFromCorner1: distFromE1,
                        distFromCorner2: distFromE2,
                        edgeLen: edgeLen,
                        edgeIndex: j,
                        keptCorner: e1OnKept ? e1 : (e2OnKept ? e2 : null),
                        keptDist: e1OnKept ? distFromE1 : (e2OnKept ? distFromE2 : Math.min(distFromE1, distFromE2)),
                        isWallCorner: false
                    });
                }
            }
        }

        // Debug: log cut polygon points and what was detected
        console.log('CUT DETAIL: cutPointsInches=' + cutPointsInches.length + ' tileVerts=' + tileVertsLocal.length + ' cutMarks=' + cutMarks.length);
        for (var i = 0; i < cutPointsInches.length; i++) {
            var p = cutPointsInches[i];
            var onEdge = false, isCorner = false;
            for (var j = 0; j < tileVertsLocal.length; j++) {
                var c = tileVertsLocal[j];
                if (Math.abs(p.x - c.x) < 0.15 && Math.abs(p.y - c.y) < 0.15) isCorner = true;
                var e2 = tileVertsLocal[(j + 1) % tileVertsLocal.length];
                if (isPointOnSegment(p.x, p.y, c.x, c.y, e2.x, e2.y, 0.3)) onEdge = true;
            }
            console.log('  pt[' + i + '] x=' + p.x.toFixed(2) + ' y=' + p.y.toFixed(2) + ' corner=' + isCorner + ' onEdge=' + onEdge);
        }
        
        // Post-process cut marks:
        // 1. Remove marks under 1/4" (negligible)
        // 2. Deduplicate: if two marks are on the same edge, keep only the one measured from kept corner
        var filteredMarks = [];
        for (var i = 0; i < cutMarks.length; i++) {
            // No minimum distance filter ‚Äî show all marks so user knows where every cut point lands
            // Check for duplicate on same edge
            var dominated = false;
            for (var d = 0; d < cutMarks.length; d++) {
                if (d === i) continue;
                if (cutMarks[d].edgeIndex === cutMarks[i].edgeIndex && !cutMarks[i].isWallCorner && !cutMarks[d].isWallCorner) {
                    // Same edge, same point (measured from opposite corners) - keep the one with a kept corner
                    var ptDist = Math.sqrt((cutMarks[i].point.x - cutMarks[d].point.x)*(cutMarks[i].point.x - cutMarks[d].point.x) + (cutMarks[i].point.y - cutMarks[d].point.y)*(cutMarks[i].point.y - cutMarks[d].point.y));
                    if (ptDist < 0.5) {
                        // Same point on same edge - keep the one with keptCorner, or shorter dist
                        if (cutMarks[d].keptCorner && !cutMarks[i].keptCorner) { dominated = true; break; }
                        if (cutMarks[d].keptCorner && cutMarks[i].keptCorner && cutMarks[i].keptDist > cutMarks[d].keptDist) { dominated = true; break; }
                    }
                }
            }
            if (!dominated) filteredMarks.push(cutMarks[i]);
        }
        cutMarks = filteredMarks;

        // Find interior points: cut polygon vertices that are NOT on any tile edge
        // These are where cut lines intersect inside the tile (e.g., wall corners).
        // The user needs X,Y measurements from tile edges to locate these points.
        var interiorMarks = [];
        var tMinXi = Infinity, tMaxXi = -Infinity, tMinYi = Infinity, tMaxYi = -Infinity;
        for (var i = 0; i < tileVertsLocal.length; i++) {
            tMinXi = Math.min(tMinXi, tileVertsLocal[i].x);
            tMaxXi = Math.max(tMaxXi, tileVertsLocal[i].x);
            tMinYi = Math.min(tMinYi, tileVertsLocal[i].y);
            tMaxYi = Math.max(tMaxYi, tileVertsLocal[i].y);
        }
        for (var i = 0; i < cutPointsInches.length; i++) {
            var p = cutPointsInches[i];
            // Check if on any tile edge
            var onTileEdge = false;
            for (var j = 0; j < tileVertsLocal.length; j++) {
                var t1 = tileVertsLocal[j];
                var t2 = tileVertsLocal[(j + 1) % tileVertsLocal.length];
                if (isPointOnSegment(p.x, p.y, t1.x, t1.y, t2.x, t2.y, 0.3)) {
                    onTileEdge = true;
                    break;
                }
            }
            if (!onTileEdge) {
                // Interior point ‚Äî compute distances from each tile edge
                var fromLeft = p.x - tMinXi;
                var fromRight = tMaxXi - p.x;
                var fromTop = p.y - tMinYi;
                var fromBottom = tMaxYi - p.y;
                interiorMarks.push({
                    point: p,
                    fromLeft: fromLeft,
                    fromRight: fromRight,
                    fromTop: fromTop,
                    fromBottom: fromBottom,
                    // Use shorter measurements for practical marking
                    xDist: Math.min(fromLeft, fromRight),
                    xFromLeft: fromLeft <= fromRight,
                    yDist: Math.min(fromTop, fromBottom),
                    yFromTop: fromTop <= fromBottom
                });
            }
        }

        // Filter out interior marks that overlap with edge marks (same point detected as both)
        var filteredInterior = [];
        for (var i = 0; i < interiorMarks.length; i++) {
            var ip = interiorMarks[i].point;
            var hasEdgeMark = false;
            for (var j = 0; j < cutMarks.length; j++) {
                var ep = cutMarks[j].point;
                var dd = Math.sqrt((ip.x - ep.x) * (ip.x - ep.x) + (ip.y - ep.y) * (ip.y - ep.y));
                if (dd < 0.5) { hasEdgeMark = true; break; }
            }
            if (!hasEdgeMark) filteredInterior.push(interiorMarks[i]);
        }
        interiorMarks = filteredInterior;

        // Compute cut line in local space (edges not on original tile)
        var cutLinePoints = [];
        for (var i = 0; i < cutPointsInches.length; i++) {
            var p1 = cutPointsInches[i];
            var p2 = cutPointsInches[(i + 1) % cutPointsInches.length];
            var isOnOriginalEdge = false;
            for (var j = 0; j < tileVertsLocal.length; j++) {
                var t1 = tileVertsLocal[j];
                var t2 = tileVertsLocal[(j + 1) % tileVertsLocal.length];
                if (isPointOnSegment(p1.x, p1.y, t1.x, t1.y, t2.x, t2.y, 0.5) &&
                    isPointOnSegment(p2.x, p2.y, t1.x, t1.y, t2.x, t2.y, 0.5)) {
                    isOnOriginalEdge = true;
                    break;
                }
            }
            if (!isOnOriginalEdge) {
                cutLinePoints.push({p1: p1, p2: p2});
            }
        }

        // Calculate total cut length
        var totalCutLen = 0;
        for (var i = 0; i < cutLinePoints.length; i++) {
            var cl = cutLinePoints[i];
            totalCutLen += Math.sqrt((cl.p2.x - cl.p1.x) * (cl.p2.x - cl.p1.x) + (cl.p2.y - cl.p1.y) * (cl.p2.y - cl.p1.y));
        }

        // Draw visualization using un-rotated local coordinates
        // The tile is shown as a flat rectangle - how you'd hold it on a saw
        // Scale to fit the full tile nicely in the view (use 120px margin)
        var drawArea = size - 180; // leave room for header and labels
        var drawScale = Math.min(drawArea / (2 * longSide / 2), drawArea / (2 * shortSide / 2));
        // But also ensure kept piece isn't tiny - zoom in if cut piece is small
        if (cutPointsInches.length >= 3) {
            var cpMinX = Infinity, cpMaxX = -Infinity, cpMinY = Infinity, cpMaxY = -Infinity;
            for (var i = 0; i < cutPointsInches.length; i++) {
                cpMinX = Math.min(cpMinX, cutPointsInches[i].x);
                cpMaxX = Math.max(cpMaxX, cutPointsInches[i].x);
                cpMinY = Math.min(cpMinY, cutPointsInches[i].y);
                cpMaxY = Math.max(cpMaxY, cutPointsInches[i].y);
            }
            // Also include full tile bounds for context
            var tMinX = Infinity, tMaxX = -Infinity, tMinY = Infinity, tMaxY = -Infinity;
            for (var i = 0; i < tileVertsLocal.length; i++) {
                tMinX = Math.min(tMinX, tileVertsLocal[i].x);
                tMaxX = Math.max(tMaxX, tileVertsLocal[i].x);
                tMinY = Math.min(tMinY, tileVertsLocal[i].y);
                tMaxY = Math.max(tMaxY, tileVertsLocal[i].y);
            }
            var spanW = tMaxX - tMinX;
            var spanH = tMaxY - tMinY;
            drawScale = Math.min(drawArea / spanW, drawArea / spanH) * 0.85;
        }
        var cx = size / 2;
        var cy = size / 2 + 55;

        // Classify cut complexity for adaptive detail
        // Simple: straight cut or rectangular notch (‚â§2 edge marks, 0 interior, ‚â§2 cut segments)
        // Moderate: L-shape or angled (>2 edge marks OR has interior marks)
        // Complex: multiple interior points
        var cutComplexity = 'simple';
        if (interiorMarks.length >= 2) {
            cutComplexity = 'complex';
        } else if (interiorMarks.length >= 1 || cutMarks.length > 2 || cutLinePoints.length > 2) {
            cutComplexity = 'moderate';
        }

        // Header ‚Äî adapts based on complexity
        ctx.fillStyle = '#333';
        ctx.font = 'bold 16px sans-serif';
        ctx.textAlign = 'center';
        var headerY = 58;

        if (cutComplexity === 'simple') {
            // Simple: just show piece dimensions and "Mark and cut" or "Cut to"
            if (cutMarks.length > 0) {
                ctx.fillText('Mark and cut:', size / 2, 35);
                ctx.fillStyle = '#2196F3';
                ctx.font = 'bold 26px sans-serif';
                var markStrs = [];
                for (var i = 0; i < cutMarks.length; i++) markStrs.push(toFraction(cutMarks[i].keptDist) + '"');
                ctx.fillText('Mark at ' + markStrs.join(' & '), size / 2, headerY);
                headerY += 26;
            } else {
                ctx.fillText('Cut to:', size / 2, 35);
                ctx.fillStyle = '#4CAF50';
                ctx.font = 'bold 28px sans-serif';
                ctx.fillText(toFraction(pieceW) + ' \u00d7 ' + toFraction(pieceH), size / 2, headerY);
                headerY += 26;
            }
        } else {
            // Moderate/Complex: show all measurements
            ctx.fillText('Mark and cut:', size / 2, 35);
            if (cutMarks.length > 0) {
                ctx.fillStyle = '#2196F3';
                var markStrs = [];
                for (var i = 0; i < cutMarks.length; i++) markStrs.push(toFraction(cutMarks[i].keptDist) + '"');
                if (cutMarks.length >= 3) {
                    ctx.font = 'bold 18px sans-serif';
                } else {
                    ctx.font = 'bold 22px sans-serif';
                }
                ctx.fillText('Edge marks: ' + markStrs.join(' & '), size / 2, headerY);
                headerY += 22;
            }
            if (interiorMarks.length > 0) {
                ctx.fillStyle = '#2E7D32';
                ctx.font = 'bold 14px sans-serif';
                for (var i = 0; i < interiorMarks.length; i++) {
                    var im = interiorMarks[i];
                    var xLabel = toFraction(im.xDist) + '" from ' + (im.xFromLeft ? 'left' : 'right');
                    var yLabel = toFraction(im.yDist) + '" from ' + (im.yFromTop ? 'top' : 'bottom');
                    ctx.fillText('Interior: ' + xLabel + ', ' + yLabel, size / 2, headerY);
                    headerY += 16;
                }
            }
        }

        // Show cut length
        if (totalCutLen > 0.1) {
            ctx.fillStyle = '#f44336';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('Cut length: ' + toFraction(totalCutLen), size / 2, headerY + 4);
        }

        // Draw the full tile as solid yellow (like void-notch style)
        ctx.fillStyle = '#FFEB3B';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (var i = 0; i < tileVertsLocal.length; i++) {
            var px = cx + tileVertsLocal[i].x * drawScale;
            var py = cy + tileVertsLocal[i].y * drawScale;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Shade the offcut area (full tile minus kept piece)
        if (cutPointsInches.length >= 3) {
            // Draw offcut as semi-transparent overlay using even-odd fill:
            // outer path = full tile, inner path = kept piece (hole)
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.beginPath();
            // Outer path: full tile
            for (var i = 0; i < tileVertsLocal.length; i++) {
                var px = cx + tileVertsLocal[i].x * drawScale;
                var py = cy + tileVertsLocal[i].y * drawScale;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            // Inner path: kept piece (wound opposite direction for even-odd)
            for (var i = cutPointsInches.length - 1; i >= 0; i--) {
                var px = cx + cutPointsInches[i].x * drawScale;
                var py = cy + cutPointsInches[i].y * drawScale;
                if (i === cutPointsInches.length - 1) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill('evenodd');
        }

        // Draw cut line (red dashed)
        if (cutLinePoints.length > 0) {
            ctx.strokeStyle = '#f44336';
            ctx.lineWidth = 3;
            ctx.setLineDash([8, 4]);
            for (var i = 0; i < cutLinePoints.length; i++) {
                var cl = cutLinePoints[i];
                ctx.beginPath();
                ctx.moveTo(cx + cl.p1.x * drawScale, cy + cl.p1.y * drawScale);
                ctx.lineTo(cx + cl.p2.x * drawScale, cy + cl.p2.y * drawScale);
                ctx.stroke();
            }
            ctx.setLineDash([]);
        }

        // Label collision avoidance: track placed label bounding boxes
        var placedLabels = [];
        function labelOverlaps(lx, ly, lw, lh) {
            for (var q = 0; q < placedLabels.length; q++) {
                var o = placedLabels[q];
                if (lx < o.x + o.w && lx + lw > o.x && ly < o.y + o.h && ly + lh > o.y) return true;
            }
            return false;
        }
        function registerLabel(lx, ly, lw, lh) {
            placedLabels.push({x: lx, y: ly, w: lw, h: lh});
        }

        // Draw measurement marks: solid blue line with brackets from kept corner to cut point
        var measureBlue = '#2196F3';
        var measureGreen = '#4CAF50';
        for (var i = 0; i < cutMarks.length; i++) {
            var mark = cutMarks[i];
            var corner = mark.keptCorner || (mark.distFromCorner1 <= mark.distFromCorner2 ? mark.corner1 : mark.corner2);
            var dist = mark.keptDist;

            if (mark.isWallCorner) continue; // skip wall corners, they're implicit

            var cPx = cx + corner.x * drawScale;
            var cPy = cy + corner.y * drawScale;
            var mPx = cx + mark.point.x * drawScale;
            var mPy = cy + mark.point.y * drawScale;

            // Solid blue measurement line along tile edge
            ctx.strokeStyle = measureBlue;
            ctx.lineWidth = 2.5;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(cPx, cPy);
            ctx.lineTo(mPx, mPy);
            ctx.stroke();

            // Bracket end caps perpendicular to edge
            var edgeDx = mPx - cPx;
            var edgeDy = mPy - cPy;
            var edgeL = Math.sqrt(edgeDx * edgeDx + edgeDy * edgeDy) || 1;
            var perpX = -edgeDy / edgeL;
            var perpY = edgeDx / edgeL;
            var bracketLen = 6;

            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cPx + perpX * bracketLen, cPy + perpY * bracketLen);
            ctx.lineTo(cPx - perpX * bracketLen, cPy - perpY * bracketLen);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(mPx + perpX * bracketLen, mPy + perpY * bracketLen);
            ctx.lineTo(mPx - perpX * bracketLen, mPy - perpY * bracketLen);
            ctx.stroke();

            // Small blue dot at corner
            ctx.fillStyle = measureBlue;
            ctx.beginPath();
            ctx.arc(cPx, cPy, 3, 0, Math.PI * 2);
            ctx.fill();

            // Label with distance (blue), offset outward from tile center
            var midX = (cPx + mPx) / 2;
            var midY = (cPy + mPy) / 2;
            var nx = -edgeDy / edgeL;
            var ny = edgeDx / edgeL;
            // Push label away from kept piece centroid
            var keptCentX = cx, keptCentY = cy;
            if (cutPointsInches.length >= 3) {
                keptCentX = 0; keptCentY = 0;
                for (var q = 0; q < cutPointsInches.length; q++) {
                    keptCentX += cx + cutPointsInches[q].x * drawScale;
                    keptCentY += cy + cutPointsInches[q].y * drawScale;
                }
                keptCentX /= cutPointsInches.length;
                keptCentY /= cutPointsInches.length;
            }
            var testDist = Math.sqrt((midX + nx * 5 - keptCentX) * (midX + nx * 5 - keptCentX) + (midY + ny * 5 - keptCentY) * (midY + ny * 5 - keptCentY));
            var testDistOther = Math.sqrt((midX - nx * 5 - keptCentX) * (midX - nx * 5 - keptCentX) + (midY - ny * 5 - keptCentY) * (midY - ny * 5 - keptCentY));
            var sign = testDist > testDistOther ? 1 : -1;

            ctx.fillStyle = '#0D47A1'; // darker navy blue for label text vs lighter bracket lines
            ctx.font = 'bold 13px sans-serif';
            ctx.textAlign = 'center';
            var labelStr = toFraction(dist) + '"';
            var lblW = ctx.measureText(labelStr).width + 4;
            var lblH = 16;
            var offset = 22;
            var lx1 = midX + sign * nx * offset - lblW / 2;
            var ly1 = midY + sign * ny * offset - lblH / 2;
            // If overlapping, try the other side
            if (labelOverlaps(lx1, ly1, lblW, lblH)) {
                sign = -sign;
                lx1 = midX + sign * nx * offset - lblW / 2;
                ly1 = midY + sign * ny * offset - lblH / 2;
            }
            // If still overlapping, push further out
            if (labelOverlaps(lx1, ly1, lblW, lblH)) {
                offset = 38;
                lx1 = midX + sign * nx * offset - lblW / 2;
                ly1 = midY + sign * ny * offset - lblH / 2;
            }
            registerLabel(lx1, ly1, lblW, lblH);
            ctx.fillText(labelStr, midX + sign * nx * offset, midY + sign * ny * offset);
        }

        // Draw interior point measurements only for moderate/complex cuts
        if (cutComplexity !== 'simple') {
        var interiorGreen = '#2E7D32';
        var tileScrLeft = cx + tMinXi * drawScale;
        var tileScrRight = cx + tMaxXi * drawScale;
        var tileScrTop = cy + tMinYi * drawScale;
        var tileScrBot = cy + tMaxYi * drawScale;

        for (var i = 0; i < interiorMarks.length; i++) {
            var im = interiorMarks[i];
            var ptX = cx + im.point.x * drawScale;
            var ptY = cy + im.point.y * drawScale;

            // Starting edge positions
            var edgeX = im.xFromLeft ? tileScrLeft : tileScrRight;
            var edgeY = im.yFromTop ? tileScrTop : tileScrBot;

            // Dashed crosshair lines from tile edge to interior point
            ctx.strokeStyle = interiorGreen;
            ctx.lineWidth = 1.5;
            ctx.setLineDash([5, 3]);

            // Horizontal line (tile edge to point)
            ctx.beginPath();
            ctx.moveTo(edgeX, ptY);
            ctx.lineTo(ptX, ptY);
            ctx.stroke();

            // Vertical line (tile edge to point)
            ctx.beginPath();
            ctx.moveTo(ptX, edgeY);
            ctx.lineTo(ptX, ptY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Orange dot at interior point
            ctx.fillStyle = interiorGreen;
            ctx.beginPath();
            ctx.arc(ptX, ptY, 4, 0, Math.PI * 2);
            ctx.fill();

            // X label: place at midpoint of the horizontal dashed line
            ctx.font = 'bold 11px sans-serif';
            var xLabelStr = toFraction(im.xDist) + '"';
            var xLblW = ctx.measureText(xLabelStr).width + 6;
            var xLblH = 14;
            var xMidX = (edgeX + ptX) / 2;
            var lx = xMidX - xLblW / 2, ly = ptY - xLblH - 3;
            if (labelOverlaps(lx, ly, xLblW, xLblH)) ly = ptY + 3;
            if (labelOverlaps(lx, ly, xLblW, xLblH)) ly = ptY - xLblH - 18;
            registerLabel(lx, ly, xLblW, xLblH);
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillRect(lx, ly, xLblW, xLblH);
            ctx.fillStyle = interiorGreen;
            ctx.fillText(xLabelStr, lx + xLblW / 2, ly + 11);

            // Y label: rotated vertical along the vertical dashed line
            var yLabelStr = toFraction(im.yDist) + '"';
            var yLblTextW = ctx.measureText(yLabelStr).width + 6;
            var yLblH = 14;
            var yMidY = (edgeY + ptY) / 2;
            // Rotated label: swap w/h for collision box
            var rotW = yLblH, rotH = yLblTextW;
            var lx2 = ptX + 4, ly2 = yMidY - rotH / 2;
            if (labelOverlaps(lx2, ly2, rotW, rotH)) lx2 = ptX - rotW - 4;
            if (labelOverlaps(lx2, ly2, rotW, rotH)) lx2 = ptX + 18;
            registerLabel(lx2, ly2, rotW, rotH);
            ctx.save();
            ctx.translate(lx2 + rotW / 2, ly2 + rotH / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            ctx.fillRect(-yLblTextW / 2, -yLblH / 2, yLblTextW, yLblH);
            ctx.fillStyle = interiorGreen;
            ctx.textAlign = 'center';
            ctx.fillText(yLabelStr, 0, yLblH / 2 - 3);
            ctx.restore();
        }
        } // end cutComplexity !== 'simple'

        } catch(e) { console.error('EDGE CUT DETAIL ERROR:', e.message, e.stack); try { ctx.restore(); } catch(ee) {} ctx.setTransform(window.devicePixelRatio || 2, 0, 0, window.devicePixelRatio || 2, 0, 0); ctx.fillStyle='red'; ctx.font='14px sans-serif'; ctx.textAlign='center'; ctx.fillText('Error: '+e.message, size/2, size/2); }
    } else {
        // Full tile fallback
        var drawScale = Math.min(140 / tileW, 140 / tileH);
        var cx = size / 2;
        var cy = size / 2 + 50;

        ctx.fillStyle = '#333';
        ctx.font = 'bold 16px sans-serif';
        ctx.fillText('Full tile', size / 2, 35);
        ctx.fillStyle = '#4CAF50';
        ctx.font = 'bold 32px sans-serif';
        var atw = tile.tw / tile.scale;
        var ath = tile.th / tile.scale;
        ctx.fillText(toFraction(Math.min(atw, ath)) + ' √ó ' + toFraction(Math.max(atw, ath)), size / 2, 75);

        ctx.fillStyle = '#FFEB3B';
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (var i = 0; i < tileVertsInches.length; i++) {
            var px = cx + tileVertsInches[i][0] * drawScale;
            var py = cy + tileVertsInches[i][1] * drawScale;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }
    
    // Restore context (undo zoom/pan transform)
    ctx.restore();
    
    // Draw zoom level indicator (outside transform)
    ctx.fillStyle = '#999';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(Math.round(detailZoom * 100) + '%', size - 10, size - 10);
    ctx.textAlign = 'center';
    
    // Tile size reference
    // Show actual tile dimensions (not bounding box which is wrong for rotated tiles)
    var actualTileW = tile.tw / tile.scale;
    var actualTileH = tile.th / tile.scale;
    ctx.fillText('Tile size: ' + toFraction(Math.min(actualTileW, actualTileH)) + ' √ó ' + toFraction(Math.max(actualTileW, actualTileH)), size / 2, size - 25);
}

// Helper: draw arrow head
function drawArrow(ctx, x, y, dir) {
    var s = 5;
    ctx.beginPath();
    if (dir === 'right') {
        ctx.moveTo(x, y);
        ctx.lineTo(x + s, y - s/2);
        ctx.lineTo(x + s, y + s/2);
    } else if (dir === 'left') {
        ctx.moveTo(x, y);
        ctx.lineTo(x - s, y - s/2);
        ctx.lineTo(x - s, y + s/2);
    } else if (dir === 'up') {
        ctx.moveTo(x, y);
        ctx.lineTo(x - s/2, y - s);
        ctx.lineTo(x + s/2, y - s);
    } else if (dir === 'down') {
        ctx.moveTo(x, y);
        ctx.lineTo(x - s/2, y + s);
        ctx.lineTo(x + s/2, y + s);
    }
    ctx.closePath();
    ctx.fill();
}

// Helper: draw rounded rectangle
function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
}

// Get ordered cut polygon points
function getCutPoints(verts, wall, voidPolys) {
    // Edge-walking algorithm: walk tile edges in order, keeping inside points
    // and inserting intersection points where edges cross wall/void boundaries.
    // This preserves correct winding order and avoids bowtie artifacts.

    var points = [];

    function isInsideValid(pt) {
        if (!inPoly(pt, wall)) return false;
        for (var vi = 0; vi < voidPolys.length; vi++) {
            if (inPoly(pt, voidPolys[vi])) return false;
        }
        return true;
    }

    function isDuplicate(pt) {
        for (var k = 0; k < points.length; k++) {
            var dx = pt[0] - points[k][0], dy = pt[1] - points[k][1];
            if (dx * dx + dy * dy < 1) return true;
        }
        return false;
    }

    function distSq(a, b) {
        return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]);
    }

    // Walk each tile edge in order
    for (var i = 0; i < verts.length; i++) {
        var v1 = verts[i];
        var v2 = verts[(i + 1) % verts.length];
        var v1Inside = isInsideValid(v1);

        // If start vertex is inside, add it
        if (v1Inside && !isDuplicate(v1)) {
            points.push(v1.slice());
        }

        // Find all intersections along this edge (with wall and voids), sorted by distance from v1
        var edgeIntersections = [];

        // Wall intersections
        for (var j = 0; j < wall.length; j++) {
            var w1 = wall[j];
            var w2 = wall[(j + 1) % wall.length];
            var inter = lineIntersect(v1, v2, w1, w2);
            if (inter) {
                edgeIntersections.push(inter);
            }
        }

        // Void intersections
        for (var vi = 0; vi < voidPolys.length; vi++) {
            var voidPoly = voidPolys[vi];
            for (var j = 0; j < voidPoly.length; j++) {
                var w1 = voidPoly[j];
                var w2 = voidPoly[(j + 1) % voidPoly.length];
                var inter = lineIntersect(v1, v2, w1, w2);
                if (inter && inPoly(inter, wall)) {
                    edgeIntersections.push(inter);
                }
            }
        }

        // Sort intersections by distance from v1
        edgeIntersections.sort(function(a, b) {
            return distSq(a, v1) - distSq(b, v1);
        });

        // Add intersections (these are boundary crossings)
        for (var k = 0; k < edgeIntersections.length; k++) {
            if (!isDuplicate(edgeIntersections[k])) {
                points.push(edgeIntersections[k]);
            }
        }
    }

    // Wall corners inside tile: needed for L-cuts.
    // Instead of appending and re-sorting, walk the existing points and find
    // where two consecutive points cross different wall edges meeting at this corner.
    // Insert the wall corner between them.
    for (var j = 0; j < wall.length; j++) {
        var wc = wall[j];
        if (!isPointInPolygon(wc, verts)) continue;
        if (isDuplicate(wc)) continue;

        // Wall edges meeting at wc: edge (j-1)->j and edge j->(j+1)
        var wPrev = wall[(j - 1 + wall.length) % wall.length];
        var wNext = wall[(j + 1) % wall.length];

        // Find two consecutive points in our polygon where:
        // one is on the incoming wall edge and the next is on the outgoing wall edge (or vice versa)
        var insertIdx = -1;
        for (var k = 0; k < points.length; k++) {
            var p1 = points[k];
            var p2 = points[(k + 1) % points.length];
            var p1OnIn = isPointOnSegment(p1[0], p1[1], wPrev[0], wPrev[1], wc[0], wc[1], 1.0);
            var p1OnOut = isPointOnSegment(p1[0], p1[1], wc[0], wc[1], wNext[0], wNext[1], 1.0);
            var p2OnIn = isPointOnSegment(p2[0], p2[1], wPrev[0], wPrev[1], wc[0], wc[1], 1.0);
            var p2OnOut = isPointOnSegment(p2[0], p2[1], wc[0], wc[1], wNext[0], wNext[1], 1.0);
            if ((p1OnIn && p2OnOut) || (p1OnOut && p2OnIn)) {
                insertIdx = k + 1;
                break;
            }
        }
        if (insertIdx >= 0) {
            points.splice(insertIdx, 0, wc.slice());
        }
    }

    // Add void corners that are inside the tile and wall
    for (var vi = 0; vi < voidPolys.length; vi++) {
        var voidPoly = voidPolys[vi];
        for (var j = 0; j < voidPoly.length; j++) {
            if (isPointInPolygon(voidPoly[j], verts) && inPoly(voidPoly[j], wall)) {
                if (!isDuplicate(voidPoly[j])) {
                    points.push(voidPoly[j].slice());
                }
            }
        }
    }

    if (points.length < 3) return points;

    // For shapes with void corners added at the end, re-sort only if needed
    // Check if the polygon self-intersects and fall back to angular sort if so
    var hasVoidCorners = false;
    for (var vi = 0; vi < voidPolys.length; vi++) {
        var voidPoly = voidPolys[vi];
        for (var j = 0; j < voidPoly.length; j++) {
            if (isPointInPolygon(voidPoly[j], verts) && inPoly(voidPoly[j], wall)) {
                hasVoidCorners = true;
                break;
            }
        }
        if (hasVoidCorners) break;
    }

    if (hasVoidCorners) {
        // With void corners, edge-walking order may not be perfect, use angular sort
        var cx = 0, cy = 0;
        for (var i = 0; i < points.length; i++) {
            cx += points[i][0];
            cy += points[i][1];
        }
        cx /= points.length;
        cy /= points.length;
        points.sort(function(a, b) {
            return Math.atan2(a[1] - cy, a[0] - cx) - Math.atan2(b[1] - cy, b[0] - cx);
        });
    }

    return points;
}

// Check if point is inside a polygon (for void corners in tile)
function isPointInPolygon(pt, poly) {
    var inside = false;
    for (var i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        var xi = poly[i][0], yi = poly[i][1];
        var xj = poly[j][0], yj = poly[j][1];
        if (((yi > pt[1]) !== (yj > pt[1])) && (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi)) {
            inside = !inside;
        }
    }
    return inside;
}

function closeDetailView(markAsCut) {
    document.getElementById('detailOverlay').classList.remove('active');
    
    if (detailTileData) {
        if (markAsCut) {
            cutTileStates[detailTileData.key] = 2; // Mark as red/cut
        } else {
            // User cancelled - reset tile back to orange
            cutTileStates[detailTileData.key] = 0;
        }
        draw();
    }
    detailTileData = null;
}

// ============ END TILE DETAIL VIEW ============

// Check if point is inside a tile (simplified bounding box check)
function isPointInTile(px, py, tx, ty, tw, th, verts) {
    // If we have vertices, use actual polygon hit test (not bounding box)
    if (verts && verts.length > 2) {
        // First check with exact polygon
        if (isPointInPolygon([px, py], verts)) return true;
        // Also check with small padding for easier tapping on edges
        // Test if point is within 6px of any polygon edge
        for (var i = 0, j = verts.length - 1; i < verts.length; j = i++) {
            var x1 = verts[j][0], y1 = verts[j][1];
            var x2 = verts[i][0], y2 = verts[i][1];
            var dx = x2 - x1, dy = y2 - y1;
            var len2 = dx * dx + dy * dy;
            if (len2 === 0) continue;
            var t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / len2));
            var cx = x1 + t * dx, cy = y1 + t * dy;
            var dist = Math.sqrt((px - cx) * (px - cx) + (py - cy) * (py - cy));
            if (dist < 6) return true;
        }
        return false;
    }

    // Fallback to bounding box
    var half = Math.max(tw, th) / 2;
    return px >= tx - half && px <= tx + half && py >= ty - half && py <= ty + half;
}

// Prevent scroll changing inputs
document.addEventListener('wheel', function(e) {
    if (document.activeElement && document.activeElement.type === 'number') {
        document.activeElement.blur();
    }
}, { passive: true });

// Close optimize menu when clicking outside
document.addEventListener('click', function(e) {
    var menu = document.getElementById('optimizeMenu');
    var btn = document.getElementById('optimizeBtn');
    if (optimizeMenuOpen && !menu.contains(e.target) && e.target !== btn) {
        closeOptimizeMenu();
    }
});

function showTab(id) {
    document.querySelectorAll('.panel').forEach(function(p) { p.classList.remove('active'); });
    document.querySelectorAll('.tab').forEach(function(t) { t.classList.remove('active'); });
    document.getElementById(id).classList.add('active');
    
    // Update active tab button
    document.querySelectorAll('.tab').forEach(function(t) {
        if (t.getAttribute('data-tab') === id) {
            t.classList.add('active');
        }
    });
    
    if (id === 'diagram') draw();
    if (id === 'projects') updateProjectList();
}

// Toast notification
function showToast(msg) {
    var existing = document.querySelector('.toast-notification');
    if (existing) existing.remove();

    var toast = document.createElement('div');
    toast.className = 'toast-notification';
    toast.textContent = msg;
    document.body.appendChild(toast);

    setTimeout(function() {
        toast.style.opacity = '0';
        toast.style.transition = 'opacity 0.3s';
        setTimeout(function() { toast.remove(); }, 300);
    }, 3000);
}

function updateWall() {
    C.wall.lH = parseFloat(document.getElementById('leftH').value) || 0;
    C.wall.rV = parseFloat(document.getElementById('rightVar').value) || 0;
    C.wall.tW = parseFloat(document.getElementById('topW').value) || 0;
    C.wall.bV = parseFloat(document.getElementById('botVar').value) || 0;
    markUnsaved();
    calculateSegments(); // Recalculate segments when wall changes
    draw();
    showTab('diagram');
}

/* ‚îÄ‚îÄ Tile Presets ‚îÄ‚îÄ */
var TILE_PRESETS = [
    // Hexagon tiles
    {name:'7√ó8 Hex (Daltile)', shape:'hexagon', nomW:7, nomH:8, actW:6.875, actH:7.875, grout:0.125},
    {name:'7√ó8 Hex (MSI)', shape:'hexagon', nomW:7, nomH:8, actW:6.8125, actH:7.8125, grout:0.125},
    {name:'6√ó7 Hex', shape:'hexagon', nomW:6, nomH:7, actW:5.875, actH:6.875, grout:0.125},
    {name:'8√ó9 Hex', shape:'hexagon', nomW:8, nomH:9, actW:7.875, actH:8.875, grout:0.125},
    {name:'10√ó11 Hex', shape:'hexagon', nomW:10, nomH:11, actW:9.875, actH:10.875, grout:0.125},
    {name:'2" Hex Mosaic', shape:'hexagon', nomW:2, nomH:2.25, actW:1.875, actH:2.125, grout:0.125},
    // Subway / Rectangle
    {name:'3√ó6 Subway', shape:'rectangle', nomW:3, nomH:6, actW:2.875, actH:5.875, grout:0.125},
    {name:'3√ó12 Subway', shape:'rectangle', nomW:3, nomH:12, actW:2.875, actH:11.875, grout:0.125},
    {name:'4√ó8 Rectangle', shape:'rectangle', nomW:4, nomH:8, actW:3.875, actH:7.875, grout:0.125},
    {name:'4√ó12 Rectangle', shape:'rectangle', nomW:4, nomH:12, actW:3.875, actH:11.875, grout:0.125},
    {name:'4√ó16 Rectangle', shape:'rectangle', nomW:4, nomH:16, actW:3.875, actH:15.875, grout:0.125},
    {name:'2√ó4 Subway', shape:'rectangle', nomW:2, nomH:4, actW:1.875, actH:3.875, grout:0.125},
    // Square tiles
    {name:'12√ó12 Square', shape:'square', nomW:12, nomH:12, actW:11.875, actH:11.875, grout:0.125},
    {name:'6√ó6 Square', shape:'square', nomW:6, nomH:6, actW:5.875, actH:5.875, grout:0.125},
    {name:'4√ó4 Square', shape:'square', nomW:4, nomH:4, actW:3.875, actH:3.875, grout:0.125},
    {name:'24√ó24 Square', shape:'square', nomW:24, nomH:24, actW:23.875, actH:23.875, grout:0.125},
    // Herringbone
    {name:'2√ó8 Herringbone', shape:'herringbone', nomW:2, nomH:8, actW:1.875, actH:7.875, grout:0.125},
    {name:'3√ó6 Herringbone', shape:'herringbone', nomW:3, nomH:6, actW:2.875, actH:5.875, grout:0.125},
    {name:'3√ó12 Herringbone', shape:'herringbone', nomW:3, nomH:12, actW:2.875, actH:11.875, grout:0.125}
];

var CUSTOM_PRESETS_KEY = 'layit-custom-presets';

function getCustomPresets() {
    try {
        var raw = localStorage.getItem(CUSTOM_PRESETS_KEY);
        return raw ? JSON.parse(raw) : [];
    } catch(e) { return []; }
}

function saveCustomPresets(list) {
    localStorage.setItem(CUSTOM_PRESETS_KEY, JSON.stringify(list));
}

function buildPresetDropdown() {
    var sel = document.getElementById('tilePreset');
    sel.innerHTML = '<option value="custom">Custom (enter below)</option>';

    // Group built-in by shape
    var groups = {};
    for (var i = 0; i < TILE_PRESETS.length; i++) {
        var p = TILE_PRESETS[i];
        if (!groups[p.shape]) groups[p.shape] = [];
        groups[p.shape].push({idx: 'b_' + i, name: p.name});
    }
    var shapeOrder = ['hexagon','rectangle','square','herringbone'];
    var shapeLabels = {hexagon:'Hexagon',rectangle:'Subway / Rectangle',square:'Square',herringbone:'Herringbone'};
    for (var si = 0; si < shapeOrder.length; si++) {
        var shape = shapeOrder[si];
        if (!groups[shape]) continue;
        var og = document.createElement('optgroup');
        og.label = shapeLabels[shape] || shape;
        for (var gi = 0; gi < groups[shape].length; gi++) {
            var opt = document.createElement('option');
            opt.value = groups[shape][gi].idx;
            opt.textContent = groups[shape][gi].name;
            og.appendChild(opt);
        }
        sel.appendChild(og);
    }

    // Custom presets
    var customs = getCustomPresets();
    if (customs.length > 0) {
        var cg = document.createElement('optgroup');
        cg.label = '‚òÖ My Presets';
        for (var ci = 0; ci < customs.length; ci++) {
            var opt = document.createElement('option');
            opt.value = 'c_' + ci;
            opt.textContent = customs[ci].name;
            cg.appendChild(opt);
        }
        sel.appendChild(cg);
    }
}

function applyPreset() {
    var val = document.getElementById('tilePreset').value;
    if (val === 'custom') return;

    var preset = null;
    if (val.indexOf('b_') === 0) {
        preset = TILE_PRESETS[parseInt(val.slice(2))];
    } else if (val.indexOf('c_') === 0) {
        preset = getCustomPresets()[parseInt(val.slice(2))];
    }
    if (!preset) return;

    document.getElementById('tileShape').value = preset.shape;
    onShape();
    document.getElementById('grout').value = preset.grout || 0.125;

    var nom = document.getElementById('nominalMode').checked;
    if (nom) {
        // In nominal mode, show the nominal (box) sizes
        document.getElementById('tileW').value = preset.nomW;
        document.getElementById('tileH').value = preset.nomH;
    } else {
        // In actual mode, show the actual measured sizes
        document.getElementById('tileW').value = preset.actW;
        document.getElementById('tileH').value = preset.actH;
    }
    onNominalToggle();
    updateTile();
}

function onNominalToggle() {
    var nom = document.getElementById('nominalMode').checked;
    var hint = document.getElementById('nominalHint');
    var readout = document.getElementById('actualReadout');
    var wLabel = document.getElementById('tileWLabel');
    var hLabel = document.getElementById('tileHLabel');

    if (nom) {
        wLabel.textContent = 'Nominal Width (in)';
        hLabel.textContent = 'Nominal Height (in)';
        hint.style.display = 'block';
        // Show the calculated actual size
        var nw = parseFloat(document.getElementById('tileW').value) || 0;
        var nh = parseFloat(document.getElementById('tileH').value) || 0;
        var gr = parseFloat(document.getElementById('grout').value) || 0.125;
        if (nw > 0 && nh > 0) {
            var aw = nw - gr;
            var ah = nh - gr;
            readout.textContent = 'Actual tile: ' + toFractionSafe(aw) + '" √ó ' + toFractionSafe(ah) + '"  (nominal ' + nw + '√ó' + nh + ' minus ' + gr + '" grout)';
            readout.style.display = 'block';
        } else {
            readout.style.display = 'none';
        }
    } else {
        wLabel.textContent = 'Actual Width (in)';
        hLabel.textContent = 'Actual Height (in)';
        hint.style.display = 'none';
        readout.style.display = 'none';
    }
}

function toFractionSafe(v) {
    // Simple fraction display for common tile sizes
    if (typeof toFraction === 'function') return toFraction(v);
    var whole = Math.floor(v);
    var frac = v - whole;
    if (frac < 0.01) return String(whole);
    if (Math.abs(frac - 0.0625) < 0.01) return whole + ' 1/16';
    if (Math.abs(frac - 0.125) < 0.01) return whole + ' 1/8';
    if (Math.abs(frac - 0.1875) < 0.01) return whole + ' 3/16';
    if (Math.abs(frac - 0.25) < 0.01) return whole + ' 1/4';
    if (Math.abs(frac - 0.375) < 0.01) return whole + ' 3/8';
    if (Math.abs(frac - 0.5) < 0.01) return whole + ' 1/2';
    if (Math.abs(frac - 0.625) < 0.01) return whole + ' 5/8';
    if (Math.abs(frac - 0.75) < 0.01) return whole + ' 3/4';
    if (Math.abs(frac - 0.875) < 0.01) return whole + ' 7/8';
    return v.toFixed(3);
}

function saveCustomPreset() {
    var w = parseFloat(document.getElementById('tileW').value) || 0;
    var h = parseFloat(document.getElementById('tileH').value) || 0;
    var shape = document.getElementById('tileShape').value;
    var grout = parseFloat(document.getElementById('grout').value) || 0.125;
    var nom = document.getElementById('nominalMode').checked;

    if (w <= 0 || h <= 0) {
        showToast('‚ö†Ô∏è Enter tile dimensions first');
        return;
    }

    var actW, actH, nomW, nomH;
    if (nom) {
        nomW = w; nomH = h;
        actW = w - grout; actH = h - grout;
    } else {
        actW = w; actH = h;
        nomW = w + grout; nomH = h + grout;
    }

    var defaultName = Math.round(nomW) + '√ó' + Math.round(nomH) + ' ' +
        shape.charAt(0).toUpperCase() + shape.slice(1);
    var name = prompt('Preset name:', defaultName);
    if (!name) return;

    var customs = getCustomPresets();
    customs.push({
        name: name,
        shape: shape,
        nomW: nomW, nomH: nomH,
        actW: actW, actH: actH,
        grout: grout
    });
    saveCustomPresets(customs);
    buildPresetDropdown();
    showToast('‚úÖ Preset "' + name + '" saved!');
}

function updateTile() {
    // Warn if there's cut progress that will be lost
    var cutCount = countCutProgress();
    if (cutCount > 0) {
        // Check if tile settings actually changed
        var newSh = document.getElementById('tileShape').value;
        var newW = parseFloat(document.getElementById('tileW').value) || 0;
        var newH = parseFloat(document.getElementById('tileH').value) || 0;
        var newGr = parseFloat(document.getElementById('grout').value);
        var nom = document.getElementById('nominalMode').checked;
        var actW = nom ? newW - newGr : newW;
        var actH = nom ? newH - newGr : newH;
        var changed = newSh !== C.tile.sh || Math.abs(actW - C.tile.w) > 0.001 || Math.abs(actH - C.tile.h) > 0.001;
        if (changed) {
            if (!confirm('You have ' + cutCount + ' tile(s) marked as cut/in-progress.\n\nChanging tile settings will reset all cut progress.\n\nSave your project first, or continue?')) {
                // Restore the dropdowns/inputs to current values
                document.getElementById('tileShape').value = C.tile.sh;
                document.getElementById('tileW').value = C.tile.w;
                document.getElementById('tileH').value = C.tile.h;
                onShape();
                return;
            }
            // User confirmed ‚Äî clear cut progress
            cutTileStates = {};
            showToast('Cut progress reset');
        }
    }

    C.tile.sh = document.getElementById('tileShape').value;
    C.tile.or = document.getElementById('tileOrient').value;
    C.tile.pattern = parseFloat(document.getElementById('tilePattern').value) || 0;
    var w = parseFloat(document.getElementById('tileW').value) || 0;
    var h = parseFloat(document.getElementById('tileH').value) || 0;
    C.tile.gr = parseFloat(document.getElementById('grout').value);

    // If nominal mode, subtract grout to get actual tile size
    var nom = document.getElementById('nominalMode').checked;
    if (nom && w > 0 && h > 0) {
        w = w - C.tile.gr;
        h = h - C.tile.gr;
    }

    if (C.tile.sh === 'square') {
        var s = w || h;
        w = h = s;
        if (nom) {
            document.getElementById('tileW').value = s + C.tile.gr;
            document.getElementById('tileH').value = s + C.tile.gr;
        } else {
            document.getElementById('tileW').value = s;
            document.getElementById('tileH').value = s;
        }
    }
    // Herringbone ratio check
    if (C.tile.sh === 'herringbone' && w > 0 && h > 0) {
        var ratio = Math.max(w, h) / Math.min(w, h);
        if (ratio < 2) {
            showToast('‚ö†Ô∏è Herringbone works best with 2:1 ratio or longer (e.g., 2"√ó8")');
        }
    }
    C.tile.w = w;
    C.tile.h = h;
    onNominalToggle(); // Update the readout
    markUnsaved();
    draw();
    showTab('diagram');
}

function onShape() {
    var s = document.getElementById('tileShape').value;
    // Hide orientation for square tiles, show for herringbone
    document.getElementById('orientDiv').style.display = s === 'square' ? 'none' : 'block';
    // Show pattern option only for square and rectangle (not hexagon or herringbone)
    document.getElementById('patternDiv').style.display = (s === 'square' || s === 'rectangle') ? 'block' : 'none';
    if (s === 'square') {
        document.getElementById('tileW').value = '';
        document.getElementById('tileH').value = '';
    }
    // For herringbone, orientation means the direction of the pattern
    if (s === 'herringbone') {
        document.getElementById('tileOrient').innerHTML = '<option value="pointy">45¬∞ Right</option><option value="flat">45¬∞ Left</option>';
        // Set default herringbone sizes (3" x 6")
        document.getElementById('tileW').value = '3';
        document.getElementById('tileH').value = '6';
    } else if (s === 'hexagon') {
        document.getElementById('tileOrient').innerHTML = '<option value="pointy">Vertical</option><option value="flat">Horizontal</option>';
    } else {
        document.getElementById('tileOrient').innerHTML = '<option value="pointy">Vertical</option><option value="flat">Horizontal</option>';
    }
}

// Pattern lock state
var patternLocked = false;
var savedPatternPosition = null; // Saved position when locked with cut tiles
var hasCutProgress = false; // Track if any tiles have been marked

// Show cut dimensions state
var showCuts = false;

function countCutProgress() {
    var count = 0;
    for (var key in cutTileStates) {
        if (cutTileStates[key] > 0) count++;
    }
    return count;
}

function toggleLock() {
    var cutCount = countCutProgress();
    
    if (patternLocked) {
        // UNLOCKING - warn if there's cut progress
        if (cutCount > 0) {
            document.getElementById('unlockWarningText').textContent = 
                'You have ' + cutCount + ' tile(s) marked. Moving the pattern will make your cut progress INVALID.';
            document.getElementById('unlockModal').classList.add('active');
            return; // Wait for modal response
        }
        // No cut progress, just unlock
        doUnlock();
    } else {
        // LOCKING - save position if there's cut progress
        if (cutCount > 0) {
            savedPatternPosition = { oxInches: C.view.oxInches || 0, oyInches: C.view.oyInches || 0 };
        }
        doLock();
    }
}

function closeUnlockModal(confirmed) {
    document.getElementById('unlockModal').classList.remove('active');
    
    if (confirmed) {
        // Save current position AND cut states before unlocking so user can restore
        savedPatternPosition = { 
            oxInches: C.view.oxInches || 0, 
            oyInches: C.view.oyInches || 0,
            cutTileStates: JSON.parse(JSON.stringify(cutTileStates)) // Deep copy of cut states
        };
        document.getElementById('restoreBtn').style.display = 'block';
        
        // Clear all cut progress - reset all tiles to orange (pattern is about to move)
        cutTileStates = {};
        
        doUnlock();
        draw(); // Redraw to show reset tiles
    }
}

function doLock() {
    patternLocked = true;
    var btn = document.getElementById('lockBtn');
    var icon = document.getElementById('lockIcon');
    var text = document.getElementById('lockText');
    var hint = document.getElementById('controlsHint');
    
    btn.className = 'btn-success';
    icon.textContent = 'üîí';
    text.textContent = 'Locked';
    hint.textContent = 'üîí Pattern locked - pan & zoom freely without moving tiles';
    hint.style.color = '#4CAF50';
    // Hide restore button when locked (pattern is safe)
    document.getElementById('restoreBtn').style.display = 'none';
}

function doUnlock() {
    patternLocked = false;
    var btn = document.getElementById('lockBtn');
    var icon = document.getElementById('lockIcon');
    var text = document.getElementById('lockText');
    var hint = document.getElementById('controlsHint');
    
    btn.className = 'btn-secondary';
    icon.textContent = 'üîì';
    text.textContent = 'Unlocked';
    hint.textContent = 'üì± One finger: pattern ‚Ä¢ Two fingers: pan & zoom | üíª Drag: pattern ‚Ä¢ Shift+drag: pan ‚Ä¢ Scroll: zoom';
    hint.style.color = '#666';
}

function restorePattern() {
    if (savedPatternPosition) {
        C.view.oxInches = savedPatternPosition.oxInches;
        C.view.oyInches = savedPatternPosition.oyInches;
        
        // Restore the cut tile states (red tiles come back!)
        if (savedPatternPosition.cutTileStates) {
            cutTileStates = JSON.parse(JSON.stringify(savedPatternPosition.cutTileStates));
        }
        
        document.getElementById('restoreBtn').style.display = 'none';
        
        // Auto-lock after restoring
        if (!patternLocked) {
            toggleLock();
        }
        draw();
    }
}

function toggleCuts() {
    showCuts = !showCuts;
    var btn = document.getElementById('cutsBtn');
    var icon = document.getElementById('cutsIcon');
    var text = document.getElementById('cutsText');
    
    if (showCuts) {
        btn.className = 'btn-success';
        icon.textContent = 'üìê';
        text.textContent = 'Cuts On';
    } else {
        btn.className = 'btn-secondary';
        icon.textContent = 'üìê';
        text.textContent = 'Cuts Off';
    }
    draw();
}

function resetView() {
    C.view.panX = 0;
    C.view.panY = 0;
    // Only reset pattern offset if unlocked
    if (!patternLocked) {
        C.view.oxInches = 0;
        C.view.oyInches = 0;
    }
    draw();
}

function updateZoom() {
    C.view.z = parseFloat(document.getElementById('zoom').value);
    document.getElementById('zoomVal').textContent = C.view.z + 'x';
    draw();
}

function draw() {
    var s = C.view.z;
    var g = C.tile.gr;
    var container = document.getElementById('canvasContainer');
    
    // Reset cut tiles data for tap detection
    cutTilesData = [];
    cutDoneCount = 0;
    
    // Calculate wall dimensions
    var rH = C.wall.lH + C.wall.rV;
    var bW = C.wall.tW + C.wall.bV;
    var maxW = Math.max(C.wall.tW, bW);
    var maxH = Math.max(C.wall.lH, rH);
    
    // Fixed viewport size - always use container size
    var viewportWidth = container.offsetWidth;
    var viewportHeight = Math.max(viewportWidth * 0.8, 400);
    
    if (projMode) {
        cv.width = window.innerWidth * 2;
        cv.height = window.innerHeight * 2;
    } else {
        cv.width = viewportWidth * 2;
        cv.height = viewportHeight * 2;
    }
    
    cx.setTransform(1, 0, 0, 1, 0, 0);
    cx.scale(2, 2);
    
    // White background
    cx.fillStyle = '#ffffff';
    cx.fillRect(0, 0, cv.width, cv.height);
    
    // Check if we have valid dimensions
    if (!C.wall.lH || !C.wall.tW || !C.tile.w || !C.tile.h) {
        cx.fillStyle = '#666666';
        cx.font = '16px sans-serif';
        cx.textAlign = 'center';
        cx.fillText('Enter wall and tile dimensions', cv.width / 4, cv.height / 4);
        return;
    }
    
    // Base offset to start drawing from
    var baseOx = 40;
    var baseOy = 40;
    
    // View pan offset (two-finger drag to navigate) - stored in pixels, that's fine for panning
    if (!C.view.panX) C.view.panX = 0;
    if (!C.view.panY) C.view.panY = 0;
    var panX = C.view.panX + (pan.dx || 0);
    var panY = C.view.panY + (pan.dy || 0);
    
    // Pattern offset - C.view.ox/oy are stored in INCHES, convert to pixels for drawing
    // drag.dx/dy are in pixels at current zoom, so divide by zoom to get inches
    if (!C.view.oxInches) C.view.oxInches = 0;
    if (!C.view.oyInches) C.view.oyInches = 0;
    var patternOxInches = C.view.oxInches + (drag.dx / s);
    var patternOyInches = C.view.oyInches + (drag.dy / s);
    var patternOx = patternOxInches * s; // Convert back to pixels for drawing
    var patternOy = patternOyInches * s;
    
    // The origin for drawing wall - combines base offset with pan
    var ox = baseOx + panX;
    var oy = baseOy + panY;
    var tw = C.tile.w * s;
    var th = C.tile.h * s;
    
    // Wall polygon
    var wall;
    if (C.polygon && C.polygon.length >= 3) {
        // Use custom polygon from perimeter drawing
        // Polygon is stored with Y=0 at bottom, but canvas Y=0 is at top
        // So we flip: canvasY = wallHeight - polygonY
        wall = C.polygon.map(function(p) {
            return [ox + p.x * s, oy + (C.wall.lH - p.y) * s];
        });
    } else {
        // Legacy rectangle mode with variance
        var hDiff = rH - C.wall.lH;
        var topRightY = oy - (hDiff * s);
        wall = [
            [ox, oy + C.wall.lH * s],  // Bottom-left
            [ox + C.wall.tW * s, oy + C.wall.lH * s + (C.wall.rV * s)],  // Bottom-right
            [ox + (C.wall.tW + C.wall.bV) * s, oy],  // Top-right
            [ox, oy]  // Top-left
        ];
    }
    
    // Void polygons
    var voidPolys = [];
    for (var vi = 0; vi < C.voids.length; vi++) {
        var v = C.voids[vi];
        voidPolys.push([
            [ox + v.x * s, oy + (C.wall.lH - v.y - v.h) * s],
            [ox + (v.x + v.w) * s, oy + (C.wall.lH - v.y - v.h) * s],
            [ox + (v.x + v.w) * s, oy + (C.wall.lH - v.y) * s],
            [ox + v.x * s, oy + (C.wall.lH - v.y) * s]
        ]);
    }
    
    // Calculate spacing (tile size + grout) in PIXELS for drawing
    var groutPx = g * s; // Grout in pixels
    var colSp, rowSp;
    
    // Also calculate spacing in INCHES for stable tile keys
    var colSpInches, rowSpInches;
    
    if (C.tile.sh === 'hexagon') {
        if (C.tile.or === 'flat') {
            colSp = th * 0.75 + groutPx;
            rowSp = tw + groutPx;
            colSpInches = C.tile.h * 0.75 + g;
            rowSpInches = C.tile.w + g;
        } else {
            colSp = tw + groutPx;
            rowSp = th * 0.75 + groutPx;
            colSpInches = C.tile.w + g;
            rowSpInches = C.tile.h * 0.75 + g;
        }
    } else if (C.tile.sh === 'square') {
        colSp = tw + groutPx;
        rowSp = th + groutPx;
        colSpInches = C.tile.w + g;
        rowSpInches = C.tile.h + g;
    } else if (C.tile.sh === 'herringbone') {
        // Herringbone geometry - CORRECT FORMULA
        // colSp = lg √ó 0.5 √ó ‚àö2 (half long side diagonal)
        // rowSp = sm √ó ‚àö2 (short side diagonal)
        var sm = Math.min(tw, th);
        var lg = Math.max(tw, th);
        var smIn = Math.min(C.tile.w, C.tile.h);
        var lgIn = Math.max(C.tile.w, C.tile.h);
        
        var sqrt2 = Math.SQRT2;
        
        colSp = lg * 0.5 * sqrt2;
        rowSp = sm * sqrt2;
        colSpInches = lgIn * 0.5 * sqrt2;
        rowSpInches = smIn * sqrt2;
    } else {
        var sm = Math.min(tw, th);
        var lg = Math.max(tw, th);
        var smIn = Math.min(C.tile.w, C.tile.h);
        var lgIn = Math.max(C.tile.w, C.tile.h);
        if (C.tile.or === 'pointy') {
            colSp = sm + groutPx;
            rowSp = lg + groutPx;
            colSpInches = smIn + g;
            rowSpInches = lgIn + g;
        } else {
            colSp = lg + groutPx;
            rowSp = sm + groutPx;
            colSpInches = lgIn + g;
            rowSpInches = smIn + g;
        }
    }
    
    // Grid bounds - calculate how many tiles we need to draw based on viewport
    // Use larger buffer for herringbone and offset patterns to ensure full edge coverage
    // Buffer scales with tile ratio for very long tiles
    var viewW = cv.width / 2;
    var viewH = cv.height / 2;
    var buffer = 4;
    if (C.tile.sh === 'herringbone') {
        var ratio = Math.max(tw, th) / Math.min(tw, th);
        buffer = Math.max(20, Math.ceil(ratio * 8));
    }
    var startCol = Math.floor((-ox - patternOx) / colSp) - buffer;
    var endCol = Math.ceil((viewW - ox - patternOx) / colSp) + buffer;
    var startRow = Math.floor((-oy - patternOy) / rowSp) - buffer;
    var endRow = Math.ceil((viewH - oy - patternOy) / rowSp) + buffer;
    
    full = 0;
    part = 0;
    var cutLabels = []; // Store cut dimensions to draw on top
    
    // Draw tiles
    for (var row = startRow; row < endRow; row++) {
        for (var col = startCol; col < endCol; col++) {
            var x = ox + col * colSp + patternOx;
            var y = oy + row * rowSp + patternOy;
            
            // Calculate stable tile position in inches for key
            var tileXInches = col * colSpInches;
            var tileYInches = row * rowSpInches;
            
            // Hex offset
            if (C.tile.sh === 'hexagon') {
                if (C.tile.or === 'pointy' && ((row % 2 + 2) % 2) === 1) {
                    x += colSp / 2;
                    tileXInches += colSpInches / 2;
                }
                if (C.tile.or === 'flat' && ((col % 2 + 2) % 2) === 1) {
                    y += rowSp / 2;
                    tileYInches += rowSpInches / 2;
                }
            }
            
            // Herringbone offset - odd columns shift by half row spacing
            if (C.tile.sh === 'herringbone') {
                var sm = Math.min(tw, th);
                var smIn = Math.min(C.tile.w, C.tile.h);
                var sqrt2 = Math.SQRT2;
                
                var rowSpacing = sm * sqrt2;
                var rowSpacingIn = smIn * sqrt2;
                
                if (((col % 2 + 2) % 2) === 1) {
                    y += rowSpacing / 2;
                    tileYInches += rowSpacingIn / 2;
                }
            }
            
            // Brick pattern offset for square/rectangle tiles
            if (C.tile.sh === 'square' || C.tile.sh === 'rectangle') {
                var patternOffset = C.tile.pattern || 0;
                if (patternOffset > 0 && ((row % 2 + 2) % 2) === 1) {
                    var offsetAmount = colSp * patternOffset;
                    var offsetAmountInches = colSpInches * patternOffset;
                    x += offsetAmount;
                    tileXInches += offsetAmountInches;
                }
            }
            
            // Create stable key based on tile position in inches (rounded to avoid float issues)
            var stableKey = Math.round(tileXInches * 1000) + ',' + Math.round(tileYInches * 1000);
            
            var verts = getVerts(x, y, tw, th, row, col);
            var allIn = true, anyIn = false;
            
            for (var i = 0; i < verts.length; i++) {
                if (inPoly(verts[i], wall)) {
                    anyIn = true;
                } else {
                    allIn = false;
                }
            }
            
            // Check void intersection
            var touchesVoid = false;
            var fullyInVoid = true;
            
            for (var vpi = 0; vpi < voidPolys.length; vpi++) {
                var vp = voidPolys[vpi];
                var allVertsInThisVoid = true;
                
                for (var i = 0; i < verts.length; i++) {
                    if (inPoly(verts[i], vp)) {
                        touchesVoid = true;
                    } else {
                        allVertsInThisVoid = false;
                    }
                }
                // Also check if void corners are inside tile
                for (var i = 0; i < vp.length; i++) {
                    if (inPoly(vp[i], verts)) {
                        touchesVoid = true;
                    }
                }
                
                if (!allVertsInThisVoid) {
                    fullyInVoid = false;
                }
            }
            
            if (C.voids.length === 0) {
                fullyInVoid = false;
            }
            
            // Draw tile if it's in the wall and not fully in a void
            if (anyIn && !fullyInVoid) {
                var isCut = !allIn || touchesVoid;
                var key = stableKey; // Use stable key based on position in inches
                var tileState = cutTileStates[key] || 0; // 0=pending, 1=selected, 2=cut
                
                if (projMode && !window.segmentProjMode) {
                    // Regular projector mode - all white for laser projection
                    cx.fillStyle = '#ffffff';
                    cx.strokeStyle = '#000000';
                    cx.lineWidth = 2;
                } else if (isCut) {
                    // Cut tile colors based on state
                    if (tileState === 0) {
                        // Orange - pending
                        cx.fillStyle = '#FF9800';
                        cx.strokeStyle = '#E65100';
                    } else if (tileState === 1) {
                        // Yellow - selected
                        cx.fillStyle = '#FFEB3B';
                        cx.strokeStyle = '#FBC02D';
                    } else {
                        // Red - cut/done
                        cx.fillStyle = '#f44336';
                        cx.strokeStyle = '#c62828';
                        cutDoneCount++;
                    }
                    cx.lineWidth = tileState === 1 ? 3 : 1; // Thicker border when selected
                } else {
                    // Full tile - green
                    cx.fillStyle = '#4CAF50';
                    cx.strokeStyle = '#2E7D32';
                    cx.lineWidth = 1;
                }
                
                drawTile(x, y, tw, th, g * s, row, col);
                cx.fill();
                cx.stroke();
                
                // Store cut tile data for tap detection and dimensions
                if (isCut && (!projMode || window.segmentProjMode)) {
                    var cutDims = getCutDimensions(verts, wall, voidPolys, s);
                    cutLabels.push({ x: x, y: y, text: cutDims || '?', state: tileState });
                    // Store all data needed for detail view
                    // Deep copy verts to avoid reference issues
                    var vertsCopy = [];
                    for (var vi = 0; vi < verts.length; vi++) {
                        vertsCopy.push([verts[vi][0], verts[vi][1]]);
                    }
                    // Deep copy wall too
                    var wallCopy = [];
                    for (var wi = 0; wi < wall.length; wi++) {
                        wallCopy.push([wall[wi][0], wall[wi][1]]);
                    }
                    cutTilesData.push({
                        key: key,
                        x: x,
                        y: y,
                        tw: tw,
                        th: th,
                        col: col,
                        row: row,
                        shape: C.tile.sh,
                        orient: C.tile.or,
                        dims: cutDims,
                        verts: vertsCopy, // Deep copy of tile vertices
                        wall: wallCopy, // Deep copy of wall polygon
                        voidPolys: voidPolys, // Reference to void polygons (these don't change)
                        scale: s // Current scale for converting back to inches
                    });
                }
                
                if (isCut) {
                    part++;
                } else {
                    full++;
                }
            }
        }
    }
    
    // Draw wall border
    cx.strokeStyle = projMode ? '#000000' : '#0D47A1';
    cx.lineWidth = projMode ? 4 : 3;
    cx.beginPath();
    cx.moveTo(wall[0][0], wall[0][1]);
    for (var i = 1; i < wall.length; i++) {
        cx.lineTo(wall[i][0], wall[i][1]);
    }
    cx.closePath();
    cx.stroke();
    
    // Draw voids (in both modes - important for tracing!)
    if (projMode) {
        // In projector mode: thick black outline for voids (for tracing)
        cx.strokeStyle = '#000000';
        cx.lineWidth = 4;
        cx.fillStyle = '#dddddd';
    } else {
        cx.fillStyle = 'rgba(0,0,0,0.8)';
        cx.strokeStyle = '#000000';
        cx.lineWidth = 2;
    }
    
    for (var vpi = 0; vpi < voidPolys.length; vpi++) {
        var vp = voidPolys[vpi];
        cx.beginPath();
        cx.moveTo(vp[0][0], vp[0][1]);
        for (var i = 1; i < vp.length; i++) {
            cx.lineTo(vp[i][0], vp[i][1]);
        }
        cx.closePath();
        cx.fill();
        cx.stroke();
    }
    
    // Draw segment grid overlay (when segments exist and in projector mode or showSegments is on)
    if (segments.length > 0 && (projMode || window.showSegmentGrid)) {
        for (var si = 0; si < segments.length; si++) {
            var seg = segments[si];
            
            // Convert segment bounds to pixels
            var segX = ox + seg.x * s;
            var segY = oy + seg.y * s;
            var segW = seg.width * s;
            var segH = seg.height * s;
            
            // Fill completed segments with red shading
            if (seg.status === 'complete') {
                cx.fillStyle = 'rgba(244, 67, 54, 0.15)'; // Light red fill
                cx.fillRect(segX, segY, segW, segH);
            }
            
            // Draw segment boundary
            if (seg.status === 'current') {
                // Current segment: bold blue border
                cx.strokeStyle = '#2196F3';
                cx.lineWidth = 5;
                cx.setLineDash([]);
            } else if (seg.status === 'complete') {
                // Complete: red dashed border
                cx.strokeStyle = '#f44336';
                cx.lineWidth = 3;
                cx.setLineDash([8, 4]);
            } else {
                // Pending: gray dashed
                cx.strokeStyle = '#666666';
                cx.lineWidth = 2;
                cx.setLineDash([10, 5]);
            }
            cx.strokeRect(segX, segY, segW, segH);
            cx.setLineDash([]);
            
            // Draw segment label
            if (!projMode) {
                cx.font = 'bold ' + Math.max(12, s * 2) + 'px sans-serif';
                cx.textAlign = 'center';
                cx.textBaseline = 'middle';
                
                var label = (seg.pathOrder + 1).toString();
                if (seg.status === 'complete') label = '‚úì';
                
                // Draw label background
                var lblW = cx.measureText(label).width + 16;
                var lblH = Math.max(12, s * 2) + 8;
                cx.fillStyle = seg.status === 'current' ? 'rgba(33, 150, 243, 0.95)' :  // Blue for current
                              seg.status === 'complete' ? 'rgba(244, 67, 54, 0.9)' :   // Red for complete
                              'rgba(100, 100, 100, 0.7)';
                cx.beginPath();
                cx.roundRect(segX + segW/2 - lblW/2, segY + segH/2 - lblH/2, lblW, lblH, 4);
                cx.fill();
                
                // Draw label text
                cx.fillStyle = '#ffffff';
                cx.fillText(label, segX + segW/2, segY + segH/2);
            }
            
            // In projector mode, highlight current segment more prominently
            if (projMode && seg.status === 'current') {
                cx.fillStyle = 'rgba(33, 150, 243, 0.08)'; // Very light blue tint
                cx.fillRect(segX, segY, segW, segH);
            }
        }
        
        // Draw recommended next segment indicator (arrow)
        if (!projMode && currentSegmentId !== null) {
            var nextId = getNextSegment();
            if (nextId !== null && segments[nextId]) {
                var next = segments[nextId];
                var nextX = ox + next.x * s + next.width * s / 2;
                var nextY = oy + next.y * s + next.height * s / 2;
                
                // Draw pulsing indicator
                cx.fillStyle = 'rgba(255, 152, 0, 0.6)';
                cx.beginPath();
                cx.arc(nextX, nextY, 15, 0, Math.PI * 2);
                cx.fill();
                cx.fillStyle = '#FF9800';
                cx.font = 'bold 16px sans-serif';
                cx.textAlign = 'center';
                cx.textBaseline = 'middle';
                cx.fillText('‚Üí', nextX, nextY);
            }
        }
    }
    
    // In segment projection mode, draw a very prominent border around current segment
    if (window.segmentProjMode && window.currentProjSegment) {
        var seg = window.currentProjSegment;
        var segX = ox + seg.x * s;
        var segY = oy + seg.y * s;
        var segW = (seg.width || 36) * s;
        var segH = (seg.height || 36) * s;
        
        // Draw thick blue border
        cx.strokeStyle = '#2196F3';
        cx.lineWidth = 6;
        cx.setLineDash([]);
        cx.strokeRect(segX, segY, segW, segH);
        
        // Draw corner markers for extra visibility
        var cornerSize = 20;
        cx.fillStyle = '#2196F3';
        // Top-left
        cx.fillRect(segX - 3, segY - 3, cornerSize, 6);
        cx.fillRect(segX - 3, segY - 3, 6, cornerSize);
        // Top-right
        cx.fillRect(segX + segW - cornerSize + 3, segY - 3, cornerSize, 6);
        cx.fillRect(segX + segW - 3, segY - 3, 6, cornerSize);
        // Bottom-left
        cx.fillRect(segX - 3, segY + segH - 3, cornerSize, 6);
        cx.fillRect(segX - 3, segY + segH - cornerSize + 3, 6, cornerSize);
        // Bottom-right
        cx.fillRect(segX + segW - cornerSize + 3, segY + segH - 3, cornerSize, 6);
        cx.fillRect(segX + segW - 3, segY + segH - cornerSize + 3, 6, cornerSize);
    }
    
    // Draw cut dimension labels ON TOP of wall border and voids
    if (!projMode && showCuts && cutLabels.length > 0) {
        cx.textAlign = 'center';
        cx.textBaseline = 'middle';
        
        // Scale font size with zoom level
        var baseSize = Math.max(10, Math.min(s * 1.5, 40)); // Scale with zoom, min 10, max 40
        var selectedSize = baseSize * 2; // Double size for selected tiles
        
        for (var i = 0; i < cutLabels.length; i++) {
            var label = cutLabels[i];
            var isSelected = label.state === 1;
            var isDone = label.state === 2;
            
            // Font scales with zoom - selected is 2x bigger
            var fontSize = isSelected ? selectedSize : baseSize;
            cx.font = 'bold ' + fontSize + 'px sans-serif';
            
            // Draw background pill for readability
            var textWidth = cx.measureText(label.text).width;
            var pillHeight = fontSize * 1.6;
            var pillY = label.y - pillHeight/2;
            var pillPadding = fontSize * 0.5;
            var pillRadius = fontSize * 0.3;
            
            // Different background colors based on state
            if (isDone) {
                cx.fillStyle = 'rgba(0,100,0,0.8)'; // Dark green for done
            } else if (isSelected) {
                cx.fillStyle = 'rgba(0,0,0,0.95)'; // Very dark for selected - more prominent
            } else {
                cx.fillStyle = 'rgba(0,0,0,0.7)';
            }
            
            cx.beginPath();
            cx.roundRect(label.x - textWidth/2 - pillPadding, pillY, textWidth + pillPadding * 2, pillHeight, pillRadius);
            cx.fill();
            
            // Draw white text (or green checkmark for done)
            cx.fillStyle = '#ffffff';
            if (isDone) {
                cx.fillText('‚úì ' + label.text, label.x, label.y);
            } else {
                cx.fillText(label.text, label.x, label.y);
            }
        }
    }
    
    // Update display
    document.getElementById('fullCount').textContent = full;
    var partialEl = document.getElementById('partialCount');
    if (partialEl) partialEl.textContent = part;
    document.getElementById('cutDoneCount').textContent = cutDoneCount;
    
    var waste = parseFloat(document.getElementById('waste').value) || 10;
    var total = full + part;
    var withWaste = Math.ceil(total * (1 + waste / 100));
    document.getElementById('tilesNeeded').textContent = withWaste + ' tiles';
    
    // Update cost estimate
    if (typeof updateCostEstimate === 'function') {
        updateCostEstimate();
    }
}

function getVerts(x, y, tw, th, row, col) {
    if (C.tile.sh === 'hexagon') {
        if (C.tile.or === 'flat') {
            var w = th, h = tw;
            return [[x-w/4,y-h/2],[x+w/4,y-h/2],[x+w/2,y],[x+w/4,y+h/2],[x-w/4,y+h/2],[x-w/2,y]];
        }
        return [[x,y-th/2],[x+tw/2,y-th/4],[x+tw/2,y+th/4],[x,y+th/2],[x-tw/2,y+th/4],[x-tw/2,y-th/4]];
    }
    if (C.tile.sh === 'square') {
        return [[x-tw/2,y-th/2],[x+tw/2,y-th/2],[x+tw/2,y+th/2],[x-tw/2,y+th/2]];
    }
    if (C.tile.sh === 'herringbone') {
        // Herringbone: alternating diagonal stripes
        // col determines which stripe (and thus which direction)
        // Even columns lean right (+45¬∞), odd columns lean left (-45¬∞)
        var w = Math.min(tw, th);  // short side
        var h = Math.max(tw, th);  // long side
        
        // Direction based on column only (not row+col)
        var angle = (col % 2 === 0) ? 45 : -45;
        if (C.tile.or === 'flat') angle = -angle; // Flip pattern direction
        
        var rad = angle * Math.PI / 180;
        var cos = Math.cos(rad);
        var sin = Math.sin(rad);
        
        // Rectangle corners centered at origin
        var corners = [
            [-w/2, -h/2],
            [w/2, -h/2],
            [w/2, h/2],
            [-w/2, h/2]
        ];
        
        // Rotate each corner around center
        return corners.map(function(c) {
            return [
                x + c[0] * cos - c[1] * sin,
                y + c[0] * sin + c[1] * cos
            ];
        });
    }
    // Rectangle
    var sm = Math.min(tw, th), lg = Math.max(tw, th);
    var w = C.tile.or === 'pointy' ? sm : lg;
    var h = C.tile.or === 'pointy' ? lg : sm;
    return [[x-w/2,y-h/2],[x+w/2,y-h/2],[x+w/2,y+h/2],[x-w/2,y+h/2]];
}

function drawTile(x, y, tw, th, g, row, col) {
    cx.beginPath();
    if (C.tile.sh === 'hexagon') {
        if (C.tile.or === 'flat') {
            var w = th - g, h = tw - g;
            cx.moveTo(x-w/4, y-h/2);
            cx.lineTo(x+w/4, y-h/2);
            cx.lineTo(x+w/2, y);
            cx.lineTo(x+w/4, y+h/2);
            cx.lineTo(x-w/4, y+h/2);
            cx.lineTo(x-w/2, y);
        } else {
            var w = tw - g, h = th - g;
            cx.moveTo(x, y-h/2);
            cx.lineTo(x+w/2, y-h/4);
            cx.lineTo(x+w/2, y+h/4);
            cx.lineTo(x, y+h/2);
            cx.lineTo(x-w/2, y+h/4);
            cx.lineTo(x-w/2, y-h/4);
        }
    } else if (C.tile.sh === 'square') {
        cx.rect(x - (tw-g)/2, y - (th-g)/2, tw - g, th - g);
    } else if (C.tile.sh === 'herringbone') {
        // Herringbone: rotated rectangle based on column stripe
        var w = Math.min(tw, th) - g;
        var h = Math.max(tw, th) - g;
        
        // Direction based on column only
        var angle = (col % 2 === 0) ? 45 : -45;
        if (C.tile.or === 'flat') angle = -angle;
        
        var rad = angle * Math.PI / 180;
        var cos = Math.cos(rad);
        var sin = Math.sin(rad);
        
        var corners = [[-w/2, -h/2], [w/2, -h/2], [w/2, h/2], [-w/2, h/2]];
        
        cx.moveTo(x + corners[0][0] * cos - corners[0][1] * sin, 
                  y + corners[0][0] * sin + corners[0][1] * cos);
        for (var i = 1; i < 4; i++) {
            cx.lineTo(x + corners[i][0] * cos - corners[i][1] * sin,
                      y + corners[i][0] * sin + corners[i][1] * cos);
        }
    } else {
        var sm = Math.min(tw, th) - g, lg = Math.max(tw, th) - g;
        var w = C.tile.or === 'pointy' ? sm : lg;
        var h = C.tile.or === 'pointy' ? lg : sm;
        cx.rect(x - w/2, y - h/2, w, h);
    }
    cx.closePath();
}

function inPoly(pt, poly) {
    var inside = false;
    for (var i = 0, j = poly.length - 1; i < poly.length; j = i++) {
        var xi = poly[i][0], yi = poly[i][1];
        var xj = poly[j][0], yj = poly[j][1];
        if (((yi > pt[1]) !== (yj > pt[1])) && (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi)) {
            inside = !inside;
        }
    }
    return inside;
}

// Calculate line segment intersection point
function lineIntersect(p1, p2, p3, p4) {
    var d = (p1[0]-p2[0])*(p3[1]-p4[1]) - (p1[1]-p2[1])*(p3[0]-p4[0]);
    if (Math.abs(d) < 0.0001) return null;
    
    var t = ((p1[0]-p3[0])*(p3[1]-p4[1]) - (p1[1]-p3[1])*(p3[0]-p4[0])) / d;
    var u = -((p1[0]-p2[0])*(p1[1]-p3[1]) - (p1[1]-p2[1])*(p1[0]-p3[0])) / d;
    
    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
        return [p1[0] + t*(p2[0]-p1[0]), p1[1] + t*(p2[1]-p1[1])];
    }
    return null;
}

// Check if a point lies on a line segment (with tolerance)
function isPointOnSegment(px, py, x1, y1, x2, y2, tolerance) {
    // Check if point is within bounding box of segment (with tolerance)
    var minX = Math.min(x1, x2) - tolerance;
    var maxX = Math.max(x1, x2) + tolerance;
    var minY = Math.min(y1, y2) - tolerance;
    var maxY = Math.max(y1, y2) + tolerance;
    
    if (px < minX || px > maxX || py < minY || py > maxY) {
        return false;
    }
    
    // Check distance from point to line
    var dx = x2 - x1;
    var dy = y2 - y1;
    var len = Math.sqrt(dx * dx + dy * dy);
    
    if (len < 0.001) {
        // Segment is essentially a point
        return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1)) <= tolerance;
    }
    
    // Distance from point to line
    var dist = Math.abs((dy * px - dx * py + x2 * y1 - y2 * x1)) / len;
    return dist <= tolerance;
}

// Get all intersection points between a tile and a polygon (wall or void)
function getIntersections(verts, poly) {
    var intersections = [];
    for (var i = 0; i < verts.length; i++) {
        var v1 = verts[i];
        var v2 = verts[(i+1) % verts.length];
        for (var j = 0; j < poly.length; j++) {
            var p1 = poly[j];
            var p2 = poly[(j+1) % poly.length];
            var inter = lineIntersect(v1, v2, p1, p2);
            if (inter) {
                intersections.push(inter);
            }
        }
    }
    return intersections;
}

// Calculate accurate cut dimensions for a partial tile
function getCutDimensions(verts, wall, voidPolys, scale) {
    // Collect all points that define the cut piece:
    // 1. Tile vertices that are inside wall and not in any void
    // 2. Intersection points with wall
    // 3. Intersection points with voids
    
    var cutPoints = [];
    
    // Add tile vertices that are inside the valid area
    for (var i = 0; i < verts.length; i++) {
        var inWall = inPoly(verts[i], wall);
        var inVoid = false;
        for (var vi = 0; vi < voidPolys.length; vi++) {
            if (inPoly(verts[i], voidPolys[vi])) {
                inVoid = true;
                break;
            }
        }
        if (inWall && !inVoid) {
            cutPoints.push(verts[i]);
        }
    }
    
    // Add intersection points with wall
    var wallInters = getIntersections(verts, wall);
    for (var i = 0; i < wallInters.length; i++) {
        var inVoid = false;
        for (var vi = 0; vi < voidPolys.length; vi++) {
            if (inPoly(wallInters[i], voidPolys[vi])) {
                inVoid = true;
                break;
            }
        }
        if (!inVoid) {
            cutPoints.push(wallInters[i]);
        }
    }
    
    // Add intersection points with voids
    for (var vi = 0; vi < voidPolys.length; vi++) {
        var voidInters = getIntersections(verts, voidPolys[vi]);
        for (var i = 0; i < voidInters.length; i++) {
            if (inPoly(voidInters[i], wall)) {
                cutPoints.push(voidInters[i]);
            }
        }
    }
    
    if (cutPoints.length < 2) {
        // Fallback to full tile size with ~ prefix
        var minX = verts[0][0], maxX = verts[0][0];
        var minY = verts[0][1], maxY = verts[0][1];
        for (var i = 1; i < verts.length; i++) {
            minX = Math.min(minX, verts[i][0]);
            maxX = Math.max(maxX, verts[i][0]);
            minY = Math.min(minY, verts[i][1]);
            maxY = Math.max(maxY, verts[i][1]);
        }
        return '~' + toFraction((maxX-minX)/scale) + '√ó' + toFraction((maxY-minY)/scale);
    }
    
    // Calculate bounding box of the cut piece
    var minX = cutPoints[0][0], maxX = cutPoints[0][0];
    var minY = cutPoints[0][1], maxY = cutPoints[0][1];
    for (var i = 1; i < cutPoints.length; i++) {
        minX = Math.min(minX, cutPoints[i][0]);
        maxX = Math.max(maxX, cutPoints[i][0]);
        minY = Math.min(minY, cutPoints[i][1]);
        maxY = Math.max(maxY, cutPoints[i][1]);
    }
    
    var widthIn = (maxX - minX) / scale;
    var heightIn = (maxY - minY) / scale;
    
    // Format as fractions
    return toFraction(widthIn) + ' √ó ' + toFraction(heightIn);
}

// Convert decimal inches to fractional string (to nearest 1/16)
function toFraction(decimal) {
    if (decimal <= 0) return '0';
    
    var whole = Math.floor(decimal);
    var remainder = decimal - whole;
    
    // Round to nearest 1/16
    var sixteenths = Math.round(remainder * 16);
    
    if (sixteenths === 0) {
        return whole === 0 ? '0' : whole + '"';
    }
    if (sixteenths === 16) {
        return (whole + 1) + '"';
    }
    
    // Simplify fraction
    var num = sixteenths;
    var den = 16;
    
    // Reduce to lowest terms
    if (num % 8 === 0) { num = num / 8; den = 2; }
    else if (num % 4 === 0) { num = num / 4; den = 4; }
    else if (num % 2 === 0) { num = num / 2; den = 8; }
    
    if (whole === 0) {
        return num + '/' + den + '"';
    }
    return whole + '-' + num + '/' + den + '"';
}

// Drag and pan variables
var pinch = { active: false, startDist: 0, startZoom: 1 };
var pan = { on: false, sx: 0, sy: 0, dx: 0, dy: 0 };

function getTouchDistance(touches) {
    var dx = touches[0].clientX - touches[1].clientX;
    var dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx * dx + dy * dy);
}

function getTouchCenter(touches) {
    return {
        x: (touches[0].clientX + touches[1].clientX) / 2,
        y: (touches[0].clientY + touches[1].clientY) / 2
    };
}

cv.addEventListener('touchstart', function(e) {
    var r = cv.getBoundingClientRect();
    
    if (e.touches.length === 2) {
        // Two fingers: pinch zoom + pan
        e.preventDefault();
        pinch.active = true;
        pinch.startDist = getTouchDistance(e.touches);
        pinch.startZoom = C.view.z;
        
        // Start pan tracking
        var center = getTouchCenter(e.touches);
        pan = { on: true, sx: center.x - r.left, sy: center.y - r.top, dx: 0, dy: 0 };
        
        drag.on = false; // Cancel any pattern drag
    } else if (e.touches.length === 1) {
        e.preventDefault();
        var t = e.touches[0];
        
        if (patternLocked || window.segmentProjMode) {
            // When locked or in segment projection, single touch = pan (not pattern adjust)
            pan = { on: true, sx: t.clientX - r.left, sy: t.clientY - r.top, dx: 0, dy: 0 };
            drag.on = false;
        } else {
            // When unlocked, single touch = pattern adjustment
            drag = { on: true, sx: t.clientX - r.left, sy: t.clientY - r.top, dx: 0, dy: 0 };
            pan.on = false;
        }
        pinch.active = false;
    }
});

cv.addEventListener('touchmove', function(e) {
    e.preventDefault();
    var r = cv.getBoundingClientRect();
    
    if (e.touches.length === 2) {
        // Two fingers: pinch zoom + pan
        
        // Handle zoom - zoom towards the pinch center
        if (pinch.active) {
            var currentDist = getTouchDistance(e.touches);
            var scale = currentDist / pinch.startDist;
            var newZoom = pinch.startZoom * scale;
            
            // Clamp zoom between 4 and 100
            newZoom = Math.max(4, Math.min(100, newZoom));
            
            // Get pinch center relative to canvas
            var center = getTouchCenter(e.touches);
            var cx = center.x - r.left;
            var cy = center.y - r.top;
            
            // Adjust pan to zoom towards pinch center
            // The point under the pinch center should stay stationary
            var zoomRatio = newZoom / C.view.z;
            
            // Calculate the point in "world" coordinates that's under the pinch center
            // Then adjust pan so it stays there after zoom
            var worldX = (cx - C.view.panX) / C.view.z;
            var worldY = (cy - C.view.panY) / C.view.z;
            
            // After zoom, where would this point be without pan adjustment?
            var newScreenX = worldX * newZoom;
            var newScreenY = worldY * newZoom;
            
            // Adjust pan to keep the point under the finger
            C.view.panX = cx - newScreenX;
            C.view.panY = cy - newScreenY;
            
            C.view.z = newZoom;
            
            // Update slider
            document.getElementById('zoom').value = Math.min(100, newZoom);
            document.getElementById('zoomVal').textContent = newZoom.toFixed(1) + 'x';
        }
        
        // Handle pan
        if (pan.on) {
            var center = getTouchCenter(e.touches);
            pan.dx = (center.x - r.left) - pan.sx;
            pan.dy = (center.y - r.top) - pan.sy;
        }
        
        draw();
    } else if (e.touches.length === 1) {
        var t = e.touches[0];
        
        if (pan.on) {
            // Single touch pan (when locked)
            pan.dx = (t.clientX - r.left) - pan.sx;
            pan.dy = (t.clientY - r.top) - pan.sy;
            draw();
        } else if (drag.on) {
            // Single touch pattern adjustment (when unlocked)
            drag.dx = (t.clientX - r.left) - drag.sx;
            drag.dy = (t.clientY - r.top) - drag.sy;
            draw();
        }
    }
});

function endDrag(e) {
    // End pinch/pan if active
    if (pinch.active || pan.on) {
        var wasPan = pan.on && (Math.abs(pan.dx) > 5 || Math.abs(pan.dy) > 5);
        
        // Commit pan offset
        if (pan.on) {
            if (!C.view.panX) C.view.panX = 0;
            if (!C.view.panY) C.view.panY = 0;
            C.view.panX += pan.dx;
            C.view.panY += pan.dy;
            
            // If it was just a tap (not a pan), check for tile tap
            if (!wasPan && e) {
                var clientX, clientY;
                if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else if (e.clientX !== undefined) {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                if (clientX !== undefined) {
                    pan = { on: false, sx: 0, sy: 0, dx: 0, dy: 0 };
                    pinch.active = false;
                    handleCanvasTap({ clientX: clientX, clientY: clientY });
                    return;
                }
            }
            
            pan = { on: false, sx: 0, sy: 0, dx: 0, dy: 0 };
        }
        pinch.active = false;
        draw();
        return;
    }
    
    if (drag.on) {
        var wasDrag = Math.abs(drag.dx) > 5 || Math.abs(drag.dy) > 5;
        // Store pattern offset in inches (divide pixel drag by current zoom)
        if (!C.view.oxInches) C.view.oxInches = 0;
        if (!C.view.oyInches) C.view.oyInches = 0;
        C.view.oxInches += drag.dx / C.view.z;
        C.view.oyInches += drag.dy / C.view.z;
        drag = { on: false, sx: 0, sy: 0, dx: 0, dy: 0 };
        
        // If it wasn't a drag (just a tap), check for tile tap
        if (!wasDrag && e) {
            var clientX, clientY;
            if (e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else if (e.clientX !== undefined) {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            if (clientX !== undefined) {
                handleCanvasTap({ clientX: clientX, clientY: clientY });
                return; // handleCanvasTap calls draw()
            }
        }
        draw();
    }
}

cv.addEventListener('touchend', endDrag);

// Mouse wheel zoom (for laptop/desktop) - zooms towards cursor
cv.addEventListener('wheel', function(e) {
    e.preventDefault();
    
    // Get cursor position relative to canvas
    var rect = cv.getBoundingClientRect();
    var cx = e.clientX - rect.left;
    var cy = e.clientY - rect.top;
    
    // Zoom in/out based on wheel direction
    var zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    var newZoom = C.view.z * zoomFactor;
    
    // Clamp zoom between 4 and 100
    newZoom = Math.max(4, Math.min(100, newZoom));
    
    // Adjust pan to zoom towards cursor position
    var worldX = (cx - C.view.panX) / C.view.z;
    var worldY = (cy - C.view.panY) / C.view.z;
    
    var newScreenX = worldX * newZoom;
    var newScreenY = worldY * newZoom;
    
    C.view.panX = cx - newScreenX;
    C.view.panY = cy - newScreenY;
    
    C.view.z = newZoom;
    
    // Update slider
    document.getElementById('zoom').value = Math.min(100, newZoom);
    document.getElementById('zoomVal').textContent = newZoom.toFixed(1) + 'x';
    
    draw();
}, { passive: false });

// Shift+drag for pan on desktop, regular drag for pattern
var shiftDown = false;
document.addEventListener('keydown', function(e) {
    if (e.key === 'Shift') shiftDown = true;
});
document.addEventListener('keyup', function(e) {
    if (e.key === 'Shift') shiftDown = false;
});

cv.addEventListener('mousedown', function(e) {
    if (shiftDown || patternLocked || window.segmentProjMode) {
        // Shift+click OR pattern locked OR segment projection = pan
        pan = { on: true, sx: e.offsetX, sy: e.offsetY, dx: 0, dy: 0 };
        drag.on = false;
    } else {
        // Regular click (unlocked) = pattern adjust
        drag = { on: true, sx: e.offsetX, sy: e.offsetY, dx: 0, dy: 0 };
        pan.on = false;
    }
});

cv.addEventListener('mousemove', function(e) {
    if (pan.on) {
        pan.dx = e.offsetX - pan.sx;
        pan.dy = e.offsetY - pan.sy;
        draw();
    } else if (drag.on) {
        drag.dx = e.offsetX - drag.sx;
        drag.dy = e.offsetY - drag.sy;
        draw();
    }
});

cv.addEventListener('mouseup', function(e) {
    if (pan.on) {
        var wasPan = Math.abs(pan.dx) > 5 || Math.abs(pan.dy) > 5;
        
        if (!C.view.panX) C.view.panX = 0;
        if (!C.view.panY) C.view.panY = 0;
        C.view.panX += pan.dx;
        C.view.panY += pan.dy;
        
        // If it was just a click (not a pan), check for tile tap
        if (!wasPan) {
            pan = { on: false, sx: 0, sy: 0, dx: 0, dy: 0 };
            handleCanvasTap({ clientX: e.clientX, clientY: e.clientY });
            return;
        }
        
        pan = { on: false, sx: 0, sy: 0, dx: 0, dy: 0 };
        draw();
    } else {
        endDrag(e);
    }
});

cv.addEventListener('mouseleave', function() {
    if (pan.on) {
        if (!C.view.panX) C.view.panX = 0;
        if (!C.view.panY) C.view.panY = 0;
        C.view.panX += pan.dx;
        C.view.panY += pan.dy;
        pan = { on: false, sx: 0, sy: 0, dx: 0, dy: 0 };
    }
    endDrag(null);
});

// Voids
function addVoid() {
    var v = {
        l: document.getElementById('voidLabel').value || 'Void',
        x: parseFloat(document.getElementById('voidX').value) || 0,
        y: parseFloat(document.getElementById('voidY').value) || 0,
        w: parseFloat(document.getElementById('voidW').value) || 0,
        h: parseFloat(document.getElementById('voidH').value) || 0
    };
    if (v.w && v.h) {
        C.voids.push(v);
        markUnsaved();
        updateVoidList();
        draw();
    }
}

function removeVoid(i) {
    C.voids.splice(i, 1);
    markUnsaved();
    updateVoidList();
    draw();
}

function updateVoidList() {
    var html = '';
    for (var i = 0; i < C.voids.length; i++) {
        var v = C.voids[i];
        html += '<div class="void-item"><span>' + v.l + ': ' + v.w + '"√ó' + v.h + '"</span><button class="btn-primary" onclick="removeVoid(' + i + ')">‚úï</button></div>';
    }
    document.getElementById('voidList').innerHTML = html;
}

var optimizeMenuOpen = false;

function toggleOptimizeMenu() {
    var menu = document.getElementById('optimizeMenu');
    optimizeMenuOpen = !optimizeMenuOpen;
    menu.style.display = optimizeMenuOpen ? 'block' : 'none';
}

function closeOptimizeMenu() {
    optimizeMenuOpen = false;
    document.getElementById('optimizeMenu').style.display = 'none';
}

function runOptimize(mode) {
    closeOptimizeMenu();
    
    // Show loading state
    var btn = document.getElementById('optimizeBtn');
    var originalText = btn.innerHTML;
    btn.innerHTML = '‚è≥ Optimizing...';
    btn.disabled = true;
    
    // Run optimization after a brief delay to show the loading state
    setTimeout(function() {
        doOptimize(mode);
        btn.innerHTML = originalText;
        btn.disabled = false;
    }, 50);
}

function doOptimize(mode) {
    var best = { score: -Infinity, x: 0, y: 0 };
    var tileW = C.tile.w;
    var tileH = C.tile.h;
    var smallCutThreshold = 0.25; // 25% of tile dimension = small cut
    
    // Save current position
    var origX = C.view.oxInches || 0;
    var origY = C.view.oyInches || 0;
    
    // Try different offsets (in inches)
    var stepX = tileW / 8;
    var stepY = tileH / 8;
    
    for (var ox = 0; ox < tileW; ox += stepX) {
        for (var oy = 0; oy < tileH; oy += stepY) {
            C.view.oxInches = ox;
            C.view.oyInches = oy;
            
            // Count tiles and analyze cuts
            var results = countTilesForOptimize();
            var score = 0;
            
            if (mode === 'fullTiles') {
                // Maximize full tiles, penalize cut tiles
                score = results.full * 100 - results.cut * 10;
            } else if (mode === 'minSmallCuts') {
                // Minimize small cuts (< 25% of tile)
                score = -results.smallCuts * 100 + results.full * 10;
            } else {
                // Balanced - maximize full tiles AND minimize small cuts
                score = results.full * 50 - results.cut * 5 - results.smallCuts * 100;
            }
            
            if (score > best.score) {
                best = { score: score, x: ox, y: oy, results: results };
            }
        }
    }
    
    // Apply best position
    C.view.oxInches = best.x;
    C.view.oyInches = best.y;
    draw();
    
    // Show results
    if (best.results) {
        console.log('Optimize results:', mode, 'Full:', best.results.full, 'Cut:', best.results.cut, 'Small cuts:', best.results.smallCuts);
    }
}

// Count tiles for optimization (without drawing)
function countTilesForOptimize() {
    var s = C.view.z;
    var g = C.tile.gr;
    var fullCount = 0;
    var cutCount = 0;
    var smallCutCount = 0;
    var smallCutThreshold = 0.25; // 25% of tile size
    
    var tw = C.tile.w * s;
    var th = C.tile.h * s;
    
    var ox = 40;
    var oy = 40;
    
    // Build wall polygon (same as draw function)
    var rH = C.wall.lH + C.wall.rV;
    var bW = C.wall.tW + C.wall.bV;
    var hDiff = rH - C.wall.lH;
    var topRightY = oy - (hDiff * s);
    var wall = [
        [ox, oy],
        [ox + C.wall.tW * s, topRightY],
        [ox + bW * s, topRightY + rH * s],
        [ox, oy + C.wall.lH * s]
    ];
    
    // Void polygons
    var voidPolys = [];
    for (var i = 0; i < C.voids.length; i++) {
        var v = C.voids[i];
        voidPolys.push([
            [ox + v.x * s, oy + (C.wall.lH - v.y - v.h) * s],
            [ox + (v.x + v.w) * s, oy + (C.wall.lH - v.y - v.h) * s],
            [ox + (v.x + v.w) * s, oy + (C.wall.lH - v.y) * s],
            [ox + v.x * s, oy + (C.wall.lH - v.y) * s]
        ]);
    }
    
    // Calculate spacing
    var colSp, rowSp;
    if (C.tile.sh === 'hexagon') {
        if (C.tile.or === 'pointy') {
            colSp = tw + g * s;
            rowSp = th * 0.75 + g * s;
        } else {
            colSp = tw * 0.75 + g * s;
            rowSp = th + g * s;
        }
    } else {
        colSp = tw + g * s;
        rowSp = th + g * s;
    }
    
    var colSpInches = colSp / s;
    var rowSpInches = rowSp / s;
    
    // Pattern offset in pixels
    var patternOxInches = C.view.oxInches || 0;
    var patternOyInches = C.view.oyInches || 0;
    var patternOx = patternOxInches * s;
    var patternOy = patternOyInches * s;
    
    // Calculate bounds
    var startCol = Math.floor((-patternOx - tw) / colSp) - 2;
    var endCol = Math.ceil((C.wall.tW * s - patternOx + tw) / colSp) + 2;
    var startRow = Math.floor((-patternOy - th) / rowSp) - 2;
    var endRow = Math.ceil((C.wall.lH * s - patternOy + th) / rowSp) + 2;
    
    for (var row = startRow; row <= endRow; row++) {
        for (var col = startCol; col <= endCol; col++) {
            var x = ox + col * colSp + patternOx;
            var y = oy + row * rowSp + patternOy;
            
            var tileXInches = col * colSpInches;
            var tileYInches = row * rowSpInches;
            
            // Hex offset
            if (C.tile.sh === 'hexagon') {
                if (C.tile.or === 'pointy' && ((row % 2 + 2) % 2) === 1) {
                    x += colSp / 2;
                    tileXInches += colSpInches / 2;
                }
                if (C.tile.or === 'flat' && ((col % 2 + 2) % 2) === 1) {
                    y += rowSp / 2;
                    tileYInches += rowSpInches / 2;
                }
            }
            
            // Brick pattern offset
            if (C.tile.sh === 'square' || C.tile.sh === 'rectangle') {
                var patternOffset = C.tile.pattern || 0;
                if (patternOffset > 0 && ((row % 2 + 2) % 2) === 1) {
                    x += colSp * patternOffset;
                    tileXInches += colSpInches * patternOffset;
                }
            }
            
            var verts = getVerts(x, y, tw, th);
            var allIn = true, anyIn = false;
            
            for (var i = 0; i < verts.length; i++) {
                if (inPoly(verts[i], wall)) {
                    anyIn = true;
                } else {
                    allIn = false;
                }
            }
            
            // Check voids
            var touchesVoid = false;
            var fullyInVoid = true;
            
            for (var vpi = 0; vpi < voidPolys.length; vpi++) {
                var vp = voidPolys[vpi];
                var allVertsInThisVoid = true;
                
                for (var i = 0; i < verts.length; i++) {
                    if (inPoly(verts[i], vp)) {
                        touchesVoid = true;
                    } else {
                        allVertsInThisVoid = false;
                    }
                }
                
                for (var i = 0; i < vp.length; i++) {
                    if (isPointInPolygon(vp[i], verts)) {
                        touchesVoid = true;
                        allVertsInThisVoid = false;
                    }
                }
                
                if (!allVertsInThisVoid) {
                    fullyInVoid = false;
                }
            }
            
            if (fullyInVoid && touchesVoid) continue;
            if (!anyIn) continue;
            
            var isCut = !allIn || touchesVoid;
            
            if (isCut) {
                cutCount++;
                
                // Check if the REMAINING piece (what stays on the wall) is a small sliver
                // OR if there's a small notch cut into the tile
                var cutPoints = getCutPoints(verts, wall, voidPolys);
                var isSmallCut = false;
                
                if (cutPoints.length >= 3) {
                    var cpMinX = Infinity, cpMaxX = -Infinity;
                    var cpMinY = Infinity, cpMaxY = -Infinity;
                    for (var i = 0; i < cutPoints.length; i++) {
                        cpMinX = Math.min(cpMinX, cutPoints[i][0]);
                        cpMaxX = Math.max(cpMaxX, cutPoints[i][0]);
                        cpMinY = Math.min(cpMinY, cutPoints[i][1]);
                        cpMaxY = Math.max(cpMaxY, cutPoints[i][1]);
                    }
                    var remainingW = (cpMaxX - cpMinX) / s; // Width of piece on wall (inches)
                    var remainingH = (cpMaxY - cpMinY) / s; // Height of piece on wall (inches)
                    
                    // Check 1: Small sliver - the remaining piece is tiny
                    if (remainingW < C.tile.w * smallCutThreshold || remainingH < C.tile.h * smallCutThreshold) {
                        isSmallCut = true;
                    }
                    
                    // Check 2: Small notch or tiny tip touching void
                    // If tile touches void, check if the notch is small OR if only a tiny bit of tile touches
                    if (!isSmallCut && touchesVoid) {
                        for (var vpi = 0; vpi < voidPolys.length; vpi++) {
                            var vp = voidPolys[vpi];
                            
                            // Get void bounds
                            var vpMinX = Infinity, vpMaxX = -Infinity;
                            var vpMinY = Infinity, vpMaxY = -Infinity;
                            for (var vi = 0; vi < vp.length; vi++) {
                                vpMinX = Math.min(vpMinX, vp[vi][0]);
                                vpMaxX = Math.max(vpMaxX, vp[vi][0]);
                                vpMinY = Math.min(vpMinY, vp[vi][1]);
                                vpMaxY = Math.max(vpMaxY, vp[vi][1]);
                            }
                            
                            // Get tile bounds
                            var tMinX = Infinity, tMaxX = -Infinity;
                            var tMinY = Infinity, tMaxY = -Infinity;
                            for (var ti = 0; ti < verts.length; ti++) {
                                tMinX = Math.min(tMinX, verts[ti][0]);
                                tMaxX = Math.max(tMaxX, verts[ti][0]);
                                tMinY = Math.min(tMinY, verts[ti][1]);
                                tMaxY = Math.max(tMaxY, verts[ti][1]);
                            }
                            
                            // Calculate bounding box overlap (notch dimensions)
                            var overlapL = Math.max(vpMinX, tMinX);
                            var overlapR = Math.min(vpMaxX, tMaxX);
                            var overlapT = Math.max(vpMinY, tMinY);
                            var overlapB = Math.min(vpMaxY, tMaxY);
                            
                            if (overlapR > overlapL && overlapB > overlapT) {
                                var notchW = (overlapR - overlapL) / s;
                                var notchH = (overlapB - overlapT) / s;
                                
                                // Small notch = either dimension < 25% of tile
                                if (notchW < C.tile.w * smallCutThreshold || notchH < C.tile.h * smallCutThreshold) {
                                    isSmallCut = true;
                                    break;
                                }
                                
                                // Also check: tiny corner/tip touching void
                                // If the overlap area is very small relative to tile area, it's a fragile tip
                                var overlapArea = notchW * notchH;
                                var tileArea = C.tile.w * C.tile.h;
                                // If overlap is less than 10% of tile area, it's a tiny tip
                                if (overlapArea < tileArea * 0.10) {
                                    isSmallCut = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (isSmallCut) {
                        smallCutCount++;
                    }
                }
            } else {
                fullCount++;
            }
        }
    }
    
    return { full: fullCount, cut: cutCount, smallCuts: smallCutCount };
}

// ==================== PROJECT MANAGEMENT ====================

var currentProjectId = null;
var unsavedChanges = false;

// Generate unique ID
function generateId() {
    return 'proj_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

// Get all projects from localStorage
function getProjects() {
    try {
        return JSON.parse(localStorage.getItem('tileProjects') || '{}');
    } catch(e) {
        return {};
    }
}

// Save projects to localStorage
function saveProjects(projects) {
    localStorage.setItem('tileProjects', JSON.stringify(projects));
}

// Mark as unsaved
function markUnsaved() {
    unsavedChanges = true;
    updateSaveStatus();
}

// Update save status display
function updateSaveStatus() {
    var statusEl = document.getElementById('saveStatus');
    if (!currentProjectId) {
        statusEl.innerHTML = '<span style="color:#FF9800">‚óè New project - not saved</span>';
    } else if (unsavedChanges) {
        statusEl.innerHTML = '<span style="color:#FF9800">‚óè Unsaved changes</span>';
    } else {
        var projects = getProjects();
        var proj = projects[currentProjectId];
        if (proj) {
            var date = new Date(proj.savedAt);
            statusEl.innerHTML = '<span style="color:#4CAF50">‚úì Saved ' + formatTimeAgo(date) + '</span>';
        }
    }
}

// Format time ago
function formatTimeAgo(date) {
    var seconds = Math.floor((new Date() - date) / 1000);
    if (seconds < 60) return 'just now';
    var minutes = Math.floor(seconds / 60);
    if (minutes < 60) return minutes + ' min ago';
    var hours = Math.floor(minutes / 60);
    if (hours < 24) return hours + ' hr ago';
    var days = Math.floor(hours / 24);
    return days + ' day' + (days > 1 ? 's' : '') + ' ago';
}

// Save current project
function saveCurrentProject() {
    var name = document.getElementById('projName').value.trim();
    if (!name) {
        alert('Please enter a project name');
        document.getElementById('projName').focus();
        return;
    }
    
    var projects = getProjects();
    
    // Create or update project
    if (!currentProjectId) {
        currentProjectId = generateId();
    }
    
    projects[currentProjectId] = {
        id: currentProjectId,
        name: name,
        config: JSON.parse(JSON.stringify(C)), // Deep copy
        cutTileStates: JSON.parse(JSON.stringify(cutTileStates)),
        savedPatternPosition: savedPatternPosition ? JSON.parse(JSON.stringify(savedPatternPosition)) : null,
        patternLocked: patternLocked,
        savedAt: Date.now()
    };
    
    saveProjects(projects);
    unsavedChanges = false;
    updateSaveStatus();
    updateProjectList();
    
    // Brief visual feedback
    var btn = event.target;
    var originalText = btn.innerHTML;
    btn.innerHTML = '‚úì Saved!';
    btn.style.background = '#46a758';
    setTimeout(function() {
        btn.innerHTML = originalText;
        btn.style.background = '';
    }, 1500);
}

// Load a project
function loadProject(id) {
    if (unsavedChanges) {
        if (!confirm('You have unsaved changes. Load anyway?')) return;
    }
    
    var projects = getProjects();
    var proj = projects[id];
    if (!proj) return;
    
    currentProjectId = id;
    C = JSON.parse(JSON.stringify(proj.config)); // Deep copy
    cutTileStates = proj.cutTileStates || {};
    
    // Restore pattern protection state
    savedPatternPosition = proj.savedPatternPosition || null;
    patternLocked = proj.patternLocked || false;
    
    // Update lock button UI
    var lockBtn = document.getElementById('lockBtn');
    var lockIcon = document.getElementById('lockIcon');
    var lockText = document.getElementById('lockText');
    var hint = document.getElementById('controlsHint');
    var restoreBtn = document.getElementById('restoreBtn');
    
    if (patternLocked) {
        lockBtn.className = 'btn-success';
        lockIcon.textContent = 'üîí';
        lockText.textContent = 'Locked';
        hint.textContent = 'üîí Pattern locked - pan & zoom freely without moving tiles';
        hint.style.color = '#4CAF50';
        restoreBtn.style.display = 'none';
    } else {
        lockBtn.className = 'btn-secondary';
        lockIcon.textContent = 'üîì';
        lockText.textContent = 'Unlocked';
        hint.textContent = 'üì± One finger: pattern ‚Ä¢ Two fingers: pan & zoom | üíª Drag: pattern ‚Ä¢ Shift+drag: pan ‚Ä¢ Scroll: zoom';
        hint.style.color = '#666';
        // Show restore button if there's a saved position and cut progress
        restoreBtn.style.display = (savedPatternPosition && countCutProgress() > 0) ? 'block' : 'none';
    }
    
    // Update UI
    document.getElementById('projName').value = proj.name;
    document.getElementById('leftH').value = C.wall.lH;
    document.getElementById('rightVar').value = C.wall.rV;
    document.getElementById('topW').value = C.wall.tW;
    document.getElementById('botVar').value = C.wall.bV;
    document.getElementById('tileShape').value = C.tile.sh;
    document.getElementById('tileOrient').value = C.tile.or;
    document.getElementById('tilePattern').value = C.tile.pattern || 0.5;
    document.getElementById('tileW').value = C.tile.w;
    document.getElementById('tileH').value = C.tile.h;
    document.getElementById('grout').value = C.tile.gr || 0.125;
    document.getElementById('tilePreset').value = 'custom';
    document.getElementById('nominalMode').checked = false;
    onNominalToggle();

    // Show/hide pattern option based on shape
    onShape();

    updateVoidList();
    unsavedChanges = false;
    updateSaveStatus();
    updateProjectList();
    draw();
    
    // Switch to diagram tab
    showTab('diagram');
}

// Delete a project
function deleteProject(id) {
    var projects = getProjects();
    var proj = projects[id];
    if (!proj) return;
    
    if (!confirm('Delete "' + proj.name + '"?\n\nThis cannot be undone.')) return;
    
    delete projects[id];
    saveProjects(projects);
    
    // If we deleted the current project, reset
    if (currentProjectId === id) {
        currentProjectId = null;
        document.getElementById('projName').value = '';
        updateSaveStatus();
    }
    
    updateProjectList();
}

// Confirm new project
function confirmNewProject() {
    if (unsavedChanges) {
        if (!confirm('You have unsaved changes. Start new project anyway?')) return;
    }
    startNewProject();
}

// Start new project
function startNewProject() {
    currentProjectId = null;
    unsavedChanges = false;
    cutTileStates = {};
    
    C = {
        wall: { lH: 0, rV: 0, tW: 0, bV: 0 },
        tile: { sh: 'hexagon', or: 'pointy', w: 0, h: 0, gr: 0.125 },
        voids: [],
        view: { z: 5, ox: 0, oy: 0 }
    };
    
    document.getElementById('projName').value = '';
    document.getElementById('leftH').value = '';
    document.getElementById('rightVar').value = '';
    document.getElementById('topW').value = '';
    document.getElementById('botVar').value = '';
    document.getElementById('tileW').value = '';
    document.getElementById('tileH').value = '';
    document.getElementById('tileShape').value = 'hexagon';
    document.getElementById('tileOrient').value = 'pointy';
    document.getElementById('tilePattern').value = '0.5';
    
    // Show/hide pattern option based on shape
    onShape();
    
    updateVoidList();
    updateSaveStatus();
    updateProjectList();
    draw();
    
    showTab('wall'); // Go to wall tab to start entering dimensions
}

// Update project list display
function updateProjectList() {
    var projects = getProjects();
    var projectIds = Object.keys(projects);
    
    var listEl = document.getElementById('projectList');
    var noProjectsEl = document.getElementById('noProjects');
    
    if (projectIds.length === 0) {
        listEl.innerHTML = '';
        noProjectsEl.style.display = 'block';
        return;
    }
    
    noProjectsEl.style.display = 'none';
    
    // Sort by saved date (newest first)
    projectIds.sort(function(a, b) {
        return projects[b].savedAt - projects[a].savedAt;
    });
    
    var html = '';
    for (var i = 0; i < projectIds.length; i++) {
        var proj = projects[projectIds[i]];
        var isActive = proj.id === currentProjectId;
        var date = new Date(proj.savedAt);
        
        html += '<div class="project-item' + (isActive ? ' active' : '') + '">';
        html += '<div class="project-item-info" onclick="loadProject(\'' + proj.id + '\')">';
        html += '<div class="project-item-name">' + (isActive ? '‚úì ' : '') + proj.name + '</div>';
        html += '<div class="project-item-date">' + formatTimeAgo(date) + '</div>';
        html += '</div>';
        html += '<div class="project-item-actions">';
        html += '<button class="btn-primary" onclick="loadProject(\'' + proj.id + '\')">Open</button>';
        html += '<button class="btn-secondary" onclick="deleteProject(\'' + proj.id + '\')" style="background:#c00;">üóë</button>';
        html += '</div>';
        html += '</div>';
    }
    
    listEl.innerHTML = html;
}

// Export current project to file
function exportProject() {
    var name = document.getElementById('projName').value.trim() || 'project';
    var data = JSON.stringify({
        name: name,
        config: C,
        cutTileStates: cutTileStates,
        exportedAt: Date.now()
    }, null, 2);
    
    var blob = new Blob([data], { type: 'application/json' });
    var a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name.replace(/[^a-z0-9]/gi, '_') + '.json';
    a.click();
}

// Import project from file
function importProject(e) {
    var file = e.target.files[0];
    if (!file) return;
    
    var reader = new FileReader();
    reader.onload = function(ev) {
        try {
            var data = JSON.parse(ev.target.result);
            
            // Support old format (config) and new format
            C = data.config || data;
            cutTileStates = data.cutTileStates || {};
            currentProjectId = null; // Treat as new project
            unsavedChanges = true;
            
            document.getElementById('projName').value = data.name || 'Imported Project';
            document.getElementById('leftH').value = C.wall.lH;
            document.getElementById('rightVar').value = C.wall.rV;
            document.getElementById('topW').value = C.wall.tW;
            document.getElementById('botVar').value = C.wall.bV;
            document.getElementById('tileShape').value = C.tile.sh;
            document.getElementById('tileOrient').value = C.tile.or;
            document.getElementById('tilePattern').value = C.tile.pattern || 0.5;
            document.getElementById('tileW').value = C.tile.w;
            document.getElementById('tileH').value = C.tile.h;
            document.getElementById('grout').value = C.tile.gr || 0.125;
            document.getElementById('tilePreset').value = 'custom';
            document.getElementById('nominalMode').checked = false;
            onNominalToggle();

            // Show/hide pattern option based on shape
            onShape();
            
            updateVoidList();
            updateSaveStatus();
            draw();
            
            alert('Project imported! Remember to save it.');
            showTab('diagram');
        } catch (err) {
            alert('Error importing project: ' + err.message);
        }
    };
    reader.readAsText(file);
    e.target.value = ''; // Reset file input
}

// Auto-save reminder on changes
function trackChanges() {
    markUnsaved();
}

// Update tile count
function updateTileCount() {
    var waste = parseFloat(document.getElementById('waste').value) || 10;
    var total = full + part;
    var tilesNeeded = Math.ceil(total * (1 + waste / 100));
    document.getElementById('tilesNeeded').textContent = tilesNeeded + ' tiles';
    document.getElementById('tilesNeeded').innerHTML = tilesNeeded + ' tiles<br><span style="font-size:12px;color:#888;">(' + full + ' full + ' + part + ' cut + ' + Math.ceil(total * waste / 100) + ' waste)</span>';
}

// Update cost estimate
function updateCostEstimate() {
    // First update tile count
    updateTileCount();
    
    var waste = parseFloat(document.getElementById('waste').value) || 10;
    var total = full + part;
    var tilesNeeded = Math.ceil(total * (1 + waste / 100));
    
    var pricePerTile = parseFloat(document.getElementById('tilePrice').value) || 0;
    var boxPrice = parseFloat(document.getElementById('boxPrice').value) || 0;
    var tilesPerBox = parseFloat(document.getElementById('tilesPerBox').value) || 0;
    
    var cost = 0;
    var breakdown = '';
    
    if (boxPrice && tilesPerBox) {
        var boxesNeeded = Math.ceil(tilesNeeded / tilesPerBox);
        cost = boxesNeeded * boxPrice;
        breakdown = boxesNeeded + ' boxes √ó $' + boxPrice.toFixed(2) + ' = ';
    } else if (pricePerTile) {
        cost = tilesNeeded * pricePerTile;
        breakdown = tilesNeeded + ' tiles √ó $' + pricePerTile.toFixed(2) + ' = ';
    }
    
    document.getElementById('costEstimate').textContent = '$' + cost.toFixed(2);
    document.getElementById('costBreakdown').textContent = breakdown ? breakdown : 'Enter price to calculate';
}

// Initialize project list on load
setTimeout(function() {
    updateProjectList();
    updateSaveStatus();
}, 100);

// ==================== END PROJECT MANAGEMENT ====================

// Projector Mode
function startProj() {
    try {
        projMode = true;
        calibrationMode = false;
        
        // Hide tabs
        document.getElementById('tabBar').style.display = 'none';
        document.body.style.background = '#ffffff';
        
        // Remove any existing overlay
        var existing = document.getElementById('projOverlay');
        if (existing) existing.remove();
        
        // Build section navigation if in section mode
        var sectionNav = '';
        if (projSection !== 'full') {
            sectionNav = '<div style="position:fixed;top:10px;left:10px;z-index:1001;display:flex;gap:5px;">' +
                '<button class="proj-btn" onclick="setSection(\'TL\');draw()" style="background:' + (projSection==='TL'?'#e5484d':'rgba(30,30,30,0.85)') + ';font-size:12px;padding:10px;">TL</button>' +
                '<button class="proj-btn" onclick="setSection(\'TR\');draw()" style="background:' + (projSection==='TR'?'#e5484d':'rgba(30,30,30,0.85)') + ';font-size:12px;padding:10px;">TR</button>' +
                '<button class="proj-btn" onclick="setSection(\'BL\');draw()" style="background:' + (projSection==='BL'?'#e5484d':'rgba(30,30,30,0.85)') + ';font-size:12px;padding:10px;">BL</button>' +
                '<button class="proj-btn" onclick="setSection(\'BR\');draw()" style="background:' + (projSection==='BR'?'#e5484d':'rgba(30,30,30,0.85)') + ';font-size:12px;padding:10px;">BR</button>' +
                '</div>';
        }
        
        // Add controls overlay
        var overlay = document.createElement('div');
        overlay.id = 'projOverlay';
        overlay.innerHTML = sectionNav +
            '<div class="proj-ctrl">' +
            '<button class="proj-btn" id="projLockBtn" onclick="toggleProjLock()" style="background:' + (patternLocked ? '#46a758' : 'rgba(30,30,30,0.85)') + '">' + (patternLocked ? 'üîí' : 'üîì') + '</button>' +
            '<button class="proj-btn" onclick="projZoom(1.25)">‚ûï</button>' +
            '<button class="proj-btn" onclick="projZoom(0.8)">‚ûñ</button>' +
            '<button class="proj-btn" style="background:#cc0000" onclick="exitProj()">‚úï</button>' +
            '</div>' +
            '<div style="position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.7);-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);color:#e6edf3;padding:10px 20px;border-radius:10px;font-size:12px;z-index:1002;border:1px solid rgba(255,255,255,0.06);" id="projStatus">' +
            (patternLocked ? 'üîí Pattern locked ‚Ä¢ ' : '') +
            (projSection !== 'full' ? 'Section: ' + projSection + ' ‚Ä¢ ' : '') +
            'Drag to pan ‚Ä¢ +/- to zoom ‚Ä¢ ‚úï to exit</div>';
        document.body.appendChild(overlay);
        
        // Make canvas fullscreen
        var container = document.getElementById('canvasContainer');
        container.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1000;border-radius:0;margin:0;background:#fff;';
        
        // Force show diagram panel
        document.getElementById('diagram').classList.add('active');
        document.getElementById('proj').classList.remove('active');
        
        // Adjust view offset for sections (use pan, not pattern offset)
        if (projSection !== 'full') {
            var wallW = Math.max(C.wall.tW, C.wall.tW + C.wall.bV);
            var wallH = Math.max(C.wall.lH, C.wall.lH + C.wall.rV);
            
            // Initialize pan if needed
            if (!C.view.panX) C.view.panX = 0;
            if (!C.view.panY) C.view.panY = 0;
            
            // Offset pan to show the correct section
            switch(projSection) {
                case 'TL': C.view.panX = 0; C.view.panY = 0; break;
                case 'TR': C.view.panX = -wallW * C.view.z / 2; C.view.panY = 0; break;
                case 'BL': C.view.panX = 0; C.view.panY = -wallH * C.view.z / 2; break;
                case 'BR': C.view.panX = -wallW * C.view.z / 2; C.view.panY = -wallH * C.view.z / 2; break;
            }
        }
        
        // Draw
        setTimeout(function() {
            draw();
        }, 100);
        
        // Try fullscreen (optional, may fail on mobile)
        try {
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen().catch(function() {});
            } else if (document.documentElement.webkitRequestFullscreen) {
                document.documentElement.webkitRequestFullscreen();
            }
        } catch(e) {}
        
    } catch(err) {
        alert('Error starting projector: ' + err.message);
    }
}

function exitProj() {
    projMode = false;
    window.segmentProjMode = false; // Clean up segment projection state
    window.currentProjSegment = null;
    
    // Restore UI
    document.getElementById('tabBar').style.display = 'flex';
    document.body.style.background = '#0d1117';
    
    // Remove overlay
    var overlay = document.getElementById('projOverlay');
    if (overlay) overlay.remove();
    
    // Restore canvas
    var container = document.getElementById('canvasContainer');
    container.style.cssText = '';
    
    // Restore panel visibility (remove forced display:none)
    var panels = document.querySelectorAll('.panel');
    panels.forEach(function(p) { 
        p.style.display = '';  // Remove inline style, let CSS handle it
    });
    
    // Go back to proj tab
    showTab('proj');
    
    // Exit fullscreen
    if (document.fullscreenElement) {
        document.exitFullscreen();
    }
    
    // Reset calibration mode
    calibrationMode = false;
    
    // Update segment UI
    updateProjectionModeUI();
    
    draw();
}

function projZoom(factor) {
    C.view.z *= factor;
    C.view.z = Math.max(4, Math.min(100, C.view.z)); // Clamp 1-100
    document.getElementById('zoom').value = Math.min(100, C.view.z);
    document.getElementById('zoomVal').textContent = C.view.z.toFixed(1) + 'x';
    draw();
}

// Toggle lock from projector mode
function toggleProjLock() {
    if (patternLocked) {
        doUnlock();
    } else {
        doLock();
    }
    
    // Update projector lock button
    var btn = document.getElementById('projLockBtn');
    if (btn) {
        btn.style.background = patternLocked ? '#46a758' : 'rgba(30,30,30,0.85)';
        btn.textContent = patternLocked ? 'üîí' : 'üîì';
    }
    
    // Update projector status
    var status = document.getElementById('projStatus');
    if (status) {
        status.textContent = (patternLocked ? 'üîí Pattern locked ‚Ä¢ ' : '') +
            (projSection !== 'full' ? 'Section: ' + projSection + ' ‚Ä¢ ' : '') +
            'Drag to pan ‚Ä¢ +/- to zoom ‚Ä¢ ‚úï to exit';
    }
}

// Generate app icon dynamically for iOS
function generateAppIcon() {
    var iconCanvas = document.createElement('canvas');
    iconCanvas.width = 180;
    iconCanvas.height = 180;
    var ctx = iconCanvas.getContext('2d');
    
    // Background
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, 180, 180);
    
    // Draw hexagon function
    function hex(cx, cy, fill, stroke) {
        var w = 20, h = 30;
        ctx.beginPath();
        ctx.moveTo(cx, cy - h/2);
        ctx.lineTo(cx + w, cy - h/4);
        ctx.lineTo(cx + w, cy + h/4);
        ctx.lineTo(cx, cy + h/2);
        ctx.lineTo(cx - w, cy + h/4);
        ctx.lineTo(cx - w, cy - h/4);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.strokeStyle = stroke;
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    // Colors
    var g = '#4CAF50', gs = '#2E7D32', o = '#FF9800', os = '#E65100';
    
    // Draw hex grid
    hex(70, 30, o, os); hex(110, 30, o, os);
    hex(50, 58, o, os); hex(90, 58, g, gs); hex(130, 58, o, os);
    hex(50, 93, g, gs); hex(90, 93, g, gs); hex(130, 93, g, gs);
    hex(50, 128, o, os); hex(90, 128, g, gs); hex(130, 128, o, os);
    hex(70, 156, o, os); hex(110, 156, o, os);
    
    // Create link element
    var link = document.createElement('link');
    link.rel = 'apple-touch-icon';
    link.href = iconCanvas.toDataURL('image/png');
    document.head.appendChild(link);
}

// Set up tab event listeners (works better on iOS than onclick)
function initTabs() {
    var tabs = document.querySelectorAll('.tab');
    tabs.forEach(function(tab) {
        // Use touchend for mobile, click for desktop
        tab.addEventListener('touchend', function(e) {
            e.preventDefault();
            var tabId = this.getAttribute('data-tab');
            if (tabId) showTab(tabId);
        });
        tab.addEventListener('click', function(e) {
            var tabId = this.getAttribute('data-tab');
            if (tabId) showTab(tabId);
        });
    });
}

// ==================== REMOTE SYNC (Legacy - kept for compatibility) ====================
var syncRole = null;
var syncRoom = null;
var syncConnected = false;
var syncPollInterval = null;

function startSyncHost() {
    showToast('Remote sync removed - use Laser Export instead');
}

function startSyncControl() {
    showToast('Remote sync removed - use Laser Export instead');
}

function showSyncConnected(role) {
    // Legacy stub
}

function disconnectSync() {
    syncRole = null;
    syncRoom = null;
    syncConnected = false;
    if (syncPollInterval) {
        clearInterval(syncPollInterval);
        syncPollInterval = null;
    }
}

function getSyncState() {
    return {
        wall: JSON.parse(JSON.stringify(C.wall)),
        tile: JSON.parse(JSON.stringify(C.tile)),
        voids: JSON.parse(JSON.stringify(C.voids)),
        view: {
            oxInches: C.view.oxInches || 0,
            oyInches: C.view.oyInches || 0,
            z: C.view.z,
            panX: C.view.panX || 0,
            panY: C.view.panY || 0
        },
        cutTileStates: JSON.parse(JSON.stringify(cutTileStates)),
        patternLocked: patternLocked
    };
}

function applySyncState(state) {
    if (state.wall) C.wall = state.wall;
    if (state.tile) C.tile = state.tile;
    if (state.voids) C.voids = state.voids;
    if (state.view) {
        C.view.oxInches = state.view.oxInches || 0;
        C.view.oyInches = state.view.oyInches || 0;
        C.view.z = state.view.z || 5;
        C.view.panX = state.view.panX || 0;
        C.view.panY = state.view.panY || 0;
    }
    if (state.cutTileStates) {
        cutTileStates = state.cutTileStates;
    }
    if (typeof state.patternLocked !== 'undefined') {
        patternLocked = state.patternLocked;
        updateLockButton();
    }
    
    // Update UI
    if (!projMode) {
        document.getElementById('leftH').value = C.wall.lH;
        document.getElementById('rightVar').value = C.wall.rV;
        document.getElementById('topW').value = C.wall.tW;
        document.getElementById('botVar').value = C.wall.bV;
        document.getElementById('tileShape').value = C.tile.sh;
        document.getElementById('tileOrient').value = C.tile.or;
        document.getElementById('tileW').value = C.tile.w;
        document.getElementById('tileH').value = C.tile.h;
        document.getElementById('grout').value = C.tile.gr || 0.125;
        document.getElementById('tilePreset').value = 'custom';
        document.getElementById('nominalMode').checked = false;
        onNominalToggle();
        document.getElementById('zoom').value = Math.min(100, C.view.z);
        document.getElementById('zoomVal').textContent = C.view.z.toFixed(1) + 'x';
        onShape();
        updateVoidList();
    }
    
    draw();
}

function setupControllerSync() {
    // Legacy stub
}

// ==================== LASER EXPORT FUNCTIONS ====================

var laserConnected = false;
var laserDevice = null;

function exportLaser() {
    var format = document.getElementById('laserFormat').value;
    var area = 'wall'; // Always export wall area only
    
    // Get wall polygon
    var wallPts = getWallPolyInches();
    
    // Get all tile vertices within the wall
    var tiles = getTilesForExport(area);
    
    if (format === 'layit') {
        exportLayItFormat(tiles, wallPts);
    } else if (format === 'svg') {
        exportSVGFormat(tiles, wallPts);
    } else if (format === 'dxf') {
        exportDXFFormat(tiles, wallPts);
    }
}

function getTilesForExport(area) {
    // Collect all tile data for export
    var tiles = [];
    var g = C.tile.gr;
    var tw = C.tile.w * 1; // in inches
    var th = C.tile.h * 1;
    
    // Calculate spacing in inches (same logic as draw())
    var sm = Math.min(tw, th);
    var lg = Math.max(tw, th);
    var sqrt2 = Math.SQRT2;
    
    var colSpInches, rowSpInches;
    
    if (C.tile.sh === 'herringbone') {
        colSpInches = lg * 0.5 * sqrt2;
        rowSpInches = sm * sqrt2;
    } else if (C.tile.sh === 'hexagon') {
        if (C.tile.or === 'pointy') {
            colSpInches = tw * 0.75 + g;
            rowSpInches = th * 0.866 + g;
        } else {
            colSpInches = tw * 0.866 + g;
            rowSpInches = th * 0.75 + g;
        }
    } else {
        colSpInches = tw + g;
        rowSpInches = th + g;
    }
    
    // Generate tile grid
    var oxInches = C.view.oxInches || 0;
    var oyInches = C.view.oyInches || 0;
    
    for (var row = -50; row < 50; row++) {
        for (var col = -50; col < 50; col++) {
            var x = col * colSpInches + oxInches;
            var y = row * rowSpInches + oyInches;
            
            // Apply offsets for different tile types
            if (C.tile.sh === 'hexagon') {
                if (C.tile.or === 'pointy' && ((row % 2 + 2) % 2) === 1) {
                    x += colSpInches / 2;
                }
                if (C.tile.or === 'flat' && ((col % 2 + 2) % 2) === 1) {
                    y += rowSpInches / 2;
                }
            }
            
            if (C.tile.sh === 'herringbone') {
                if (((col % 2 + 2) % 2) === 1) {
                    y += rowSpInches / 2;
                }
            }
            
            // Get tile vertices
            var verts = getTileVertsInches(x, y, tw, th, row, col);
            
            // Check if tile intersects wall
            var wallPoly = getWallPolyInches();
            if (polyIntersects(verts, wallPoly)) {
                tiles.push({
                    x: x,
                    y: y,
                    verts: verts,
                    row: row,
                    col: col
                });
            }
        }
    }
    
    return tiles;
}

function getTileVertsInches(x, y, tw, th, row, col) {
    var g = C.tile.gr;
    var w = tw - g;
    var h = th - g;
    
    if (C.tile.sh === 'herringbone') {
        var sm = Math.min(w, h);
        var lg = Math.max(w, h);
        var angle = (col % 2 === 0) ? 45 : -45;
        if (C.tile.or === 'flat') angle = -angle;
        var rad = angle * Math.PI / 180;
        var cos = Math.cos(rad);
        var sin = Math.sin(rad);
        
        var corners = [[-sm/2, -lg/2], [sm/2, -lg/2], [sm/2, lg/2], [-sm/2, lg/2]];
        return corners.map(function(c) {
            return [x + c[0] * cos - c[1] * sin, y + c[0] * sin + c[1] * cos];
        });
    } else if (C.tile.sh === 'hexagon') {
        if (C.tile.or === 'pointy') {
            return [
                [x, y - h/2], [x + w/4, y - h/4], [x + w/4, y + h/4],
                [x, y + h/2], [x - w/4, y + h/4], [x - w/4, y - h/4]
            ];
        } else {
            return [
                [x - w/2, y], [x - w/4, y - h/4], [x + w/4, y - h/4],
                [x + w/2, y], [x + w/4, y + h/4], [x - w/4, y + h/4]
            ];
        }
    } else {
        // Rectangle/Square
        return [[x - w/2, y - h/2], [x + w/2, y - h/2], [x + w/2, y + h/2], [x - w/2, y + h/2]];
    }
}

function getWallPolyInches() {
    // If we have a custom polygon from perimeter drawing, use it
    if (C.polygon && C.polygon.length >= 3) {
        return C.polygon.map(function(p) {
            return [p.x, p.y];
        });
    }
    
    // Legacy rectangle mode with optional variance
    return [
        [0, 0],
        [C.wall.tW, C.wall.rV],
        [C.wall.tW + C.wall.bV, C.wall.lH + C.wall.rV],
        [C.wall.bV, C.wall.lH]
    ];
}

function polyIntersects(poly1, poly2) {
    // Simple bounding box check for now
    var b1 = getBounds(poly1);
    var b2 = getBounds(poly2);
    return !(b1.maxX < b2.minX || b1.minX > b2.maxX || b1.maxY < b2.minY || b1.minY > b2.maxY);
}

function getBounds(poly) {
    var xs = poly.map(function(p) { return p[0]; });
    var ys = poly.map(function(p) { return p[1]; });
    return {
        minX: Math.min.apply(null, xs),
        maxX: Math.max.apply(null, xs),
        minY: Math.min.apply(null, ys),
        maxY: Math.max.apply(null, ys)
    };
}

function exportLayItFormat(tiles, wallPts) {
    var data = {
        version: '1.0',
        type: 'layit-laser',
        wall: {
            width: C.wall.tW,
            height: C.wall.lH,
            polygon: getWallPolyInches()
        },
        tile: {
            shape: C.tile.sh,
            width: C.tile.w,
            height: C.tile.h,
            grout: C.tile.gr
        },
        voids: C.voids,
        tiles: tiles.map(function(t) {
            return { x: t.x, y: t.y, verts: t.verts };
        })
    };
    
    try {
        var jsonStr = JSON.stringify(data, null, 2);
        var dataStr = 'data:application/json;base64,' + btoa(unescape(encodeURIComponent(jsonStr)));
        var a = document.createElement('a');
        a.href = dataStr;
        a.download = (document.getElementById('projName').value || 'pattern') + '.layit';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        showToast('‚úÖ LayIt format exported!');
    } catch(e) {
        showToast('‚ö†Ô∏è Export failed: ' + e.message);
    }
}

function exportSVGFormat(tiles, wallPts) {
    var wallPoly = getWallPolyInches();
    
    // Use wall bounds, not tile bounds
    var w = Math.max(C.wall.tW, C.wall.tW + C.wall.bV);
    var h = Math.max(C.wall.lH, C.wall.lH + C.wall.rV);
    var scale = 10; // 10 pixels per inch for reasonable file size
    
    var svg = '<?xml version="1.0" encoding="UTF-8"?>\n';
    svg += '<svg xmlns="http://www.w3.org/2000/svg" width="' + (w * scale) + '" height="' + (h * scale) + '" viewBox="0 0 ' + w + ' ' + h + '">\n';
    svg += '  <desc>LayIt Tile Pattern Export</desc>\n';
    
    // Wall outline
    svg += '  <polygon points="' + wallPoly.map(function(p) { 
        return p[0] + ',' + p[1]; 
    }).join(' ') + '" fill="none" stroke="#333" stroke-width="0.1"/>\n';
    
    // Tiles - filter to only those within wall bounds
    svg += '  <g id="tiles" fill="none" stroke="#000" stroke-width="0.05">\n';
    tiles.forEach(function(t) {
        // Check if tile center is within wall bounds (simple check)
        if (t.x >= 0 && t.x <= w && t.y >= 0 && t.y <= h) {
            svg += '    <polygon points="' + t.verts.map(function(p) { 
                return p[0] + ',' + p[1]; 
            }).join(' ') + '"/>\n';
        }
    });
    svg += '  </g>\n';
    
    // Voids - Y is stored as "from bottom", SVG Y goes down from top
    if (C.voids && C.voids.length > 0) {
        svg += '  <g id="voids" fill="none" stroke="#f00" stroke-width="0.1">\n';
        C.voids.forEach(function(v) {
            // Flip Y: wall height - void Y - void height
            var svgY = h - v.y - v.h;
            svg += '    <rect x="' + v.x + '" y="' + svgY + '" width="' + v.w + '" height="' + v.h + '"/>\n';
        });
        svg += '  </g>\n';
    }
    
    svg += '</svg>';
    
    try {
        var dataStr = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
        var a = document.createElement('a');
        a.href = dataStr;
        a.download = (document.getElementById('projName').value || 'pattern') + '.svg';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        showToast('‚úÖ SVG exported!');
    } catch(e) {
        // Fallback: open in new window
        var win = window.open('', '_blank');
        win.document.write('<pre>' + svg.replace(/</g, '&lt;') + '</pre>');
        showToast('SVG opened in new tab - right-click to save');
    }
}

function exportDXFFormat(tiles, wallPts) {
    var wallPoly = getWallPolyInches();
    
    // Simple DXF format
    var dxf = '0\nSECTION\n2\nENTITIES\n';
    
    // Wall outline
    dxf += '0\nPOLYLINE\n8\nWALL\n66\n1\n70\n1\n';
    wallPoly.forEach(function(p) {
        dxf += '0\nVERTEX\n8\nWALL\n10\n' + p[0] + '\n20\n' + p[1] + '\n30\n0\n';
    });
    dxf += '0\nSEQEND\n';
    
    // Tiles
    tiles.forEach(function(t, i) {
        dxf += '0\nPOLYLINE\n8\nTILES\n66\n1\n70\n1\n';
        t.verts.forEach(function(p) {
            dxf += '0\nVERTEX\n8\nTILES\n10\n' + p[0] + '\n20\n' + p[1] + '\n30\n0\n';
        });
        dxf += '0\nSEQEND\n';
    });
    
    // Voids
    if (C.voids && C.voids.length > 0) {
        C.voids.forEach(function(v) {
            dxf += '0\nPOLYLINE\n8\nVOIDS\n66\n1\n70\n1\n';
            [[v.x, v.y], [v.x + v.w, v.y], [v.x + v.w, v.y + v.h], [v.x, v.y + v.h]].forEach(function(p) {
                dxf += '0\nVERTEX\n8\nVOIDS\n10\n' + p[0] + '\n20\n' + p[1] + '\n30\n0\n';
            });
            dxf += '0\nSEQEND\n';
        });
    }
    
    dxf += '0\nENDSEC\n0\nEOF\n';
    
    try {
        var dataStr = 'data:application/dxf;base64,' + btoa(unescape(encodeURIComponent(dxf)));
        var a = document.createElement('a');
        a.href = dataStr;
        a.download = (document.getElementById('projName').value || 'pattern') + '.dxf';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        showToast('‚úÖ DXF exported!');
    } catch(e) {
        showToast('‚ö†Ô∏è Export failed: ' + e.message);
    }
}

function scanLasers() {
    showToast('üîÑ Scanning for LayIt Laser devices...');
    // Placeholder - in real implementation, this would scan WiFi/Bluetooth
    setTimeout(function() {
        document.getElementById('laserDevice').innerHTML = '<option value="demo">LayIt Laser Demo (Simulated)</option>';
        showToast('Found 1 device');
    }, 1500);
}

function connectLaser() {
    var device = document.getElementById('laserDevice').value;
    if (!device) {
        showToast('‚ö†Ô∏è Select a device first');
        return;
    }
    
    showToast('üîó Connecting...');
    // Placeholder - simulate connection
    setTimeout(function() {
        laserConnected = true;
        laserDevice = device;
        document.getElementById('laserNotConnected').style.display = 'none';
        document.getElementById('laserConnected').style.display = 'block';
        document.getElementById('laserDeviceName').textContent = 'LayIt Laser Demo';
        
        // Switch to detected distance mode
        document.getElementById('distanceInputSection').style.display = 'none';
        document.getElementById('detectedDistanceSection').style.display = 'block';
        
        // Simulate detected distance (would come from laser camera)
        var detectedDist = 6.2;
        document.getElementById('detectedDistance').textContent = detectedDist + ' ft';
        document.getElementById('detectedDistanceLabel').textContent = 
            segmentState.surface === 'wall' ? 'from wall (detected)' : 'beam distance (detected)';
        
        segmentState.distance = detectedDist;
        segmentState.coverage = getCoverageFromDistance(detectedDist);
        updateCoverageDisplay();
        calculateSegments();
        
        showToast('‚úÖ Connected!');
    }, 1000);
}

function disconnectLaser() {
    laserConnected = false;
    laserDevice = null;
    document.getElementById('laserNotConnected').style.display = 'block';
    document.getElementById('laserConnected').style.display = 'none';
    
    // Switch back to input mode
    document.getElementById('distanceInputSection').style.display = 'block';
    document.getElementById('detectedDistanceSection').style.display = 'none';
    
    // Recalculate based on current slider values
    if (segmentState.surface === 'wall') {
        updateFromDistance();
    } else {
        updateFloorCoverage();
    }
    
    showToast('üîå Disconnected');
}

function sendToLaser() {
    if (!laserConnected) {
        showToast('‚ö†Ô∏è Not connected to laser');
        return;
    }
    
    showToast('üî¥ Sending pattern to laser...');
    // Placeholder - would send data to actual device
    setTimeout(function() {
        document.getElementById('laserStatus').textContent = 'Projecting pattern...';
        showToast('‚úÖ Pattern sent! Laser is projecting.');
    }, 500);
}

function laserPreview() {
    showToast('üëÅÔ∏è Preview mode - laser showing outline only');
}

function laserStop() {
    if (laserConnected) {
        document.getElementById('laserStatus').textContent = 'Ready to project';
        showToast('‚èπÔ∏è Laser stopped');
    }
}

function startLaserCalibration() {
    showToast('üìè Calibration mode - laser projecting 12" square');
    // Would send calibration pattern to laser
}

// ==================== END LASER FUNCTIONS ====================

// ==================== AUTO-SAVE LAST SESSION ====================

// Save current state to localStorage (called on any change)
function autoSaveState() {
    try {
        var state = {
            C: C,
            cutTileStates: cutTileStates,
            timestamp: Date.now()
        };
        localStorage.setItem('layit_autosave', JSON.stringify(state));
    } catch (e) {
        // localStorage might be full or unavailable
    }
}

// Restore last session state on load
function autoRestoreState() {
    try {
        var saved = localStorage.getItem('layit_autosave');
        if (!saved) return false;
        
        var state = JSON.parse(saved);
        
        // Check if save is recent (within 7 days)
        var age = Date.now() - state.timestamp;
        if (age > 7 * 24 * 60 * 60 * 1000) {
            localStorage.removeItem('layit_autosave');
            return false;
        }
        
        // Restore state
        if (state.C) {
            C = state.C;
            cutTileStates = state.cutTileStates || {};
            
            // Update form fields to match restored state
            if (document.getElementById('quickWidth')) {
                document.getElementById('quickWidth').value = C.wall.tW || '';
                document.getElementById('quickHeight').value = C.wall.lH || '';
            }
            if (document.getElementById('tileShape')) {
                document.getElementById('tileShape').value = C.tile.sh || 'hexagon';
                document.getElementById('tileOrient').value = C.tile.or || 'pointy';
                document.getElementById('tileW').value = C.tile.w || '';
                document.getElementById('tileH').value = C.tile.h || '';
                document.getElementById('grout').value = C.tile.gr || 0.125;
                document.getElementById('tilePreset').value = 'custom';
                document.getElementById('nominalMode').checked = false;
                onNominalToggle();
                if (document.getElementById('tilePattern')) {
                    document.getElementById('tilePattern').value = C.tile.pattern || 0.5;
                }
                onShape(); // Update UI based on shape
            }
            
            return true;
        }
    } catch (e) {
        // JSON parse error or other issue
    }
    return false;
}

// Hook auto-save into state changes
var originalDraw = draw;
draw = function() {
    originalDraw();
    autoSaveState();
};

// ==================== END AUTO-SAVE ====================

// Initialize
initTabs();
buildPresetDropdown();
generateAppIcon();

// Try to restore last session first
var restored = autoRestoreState();

updateVoidList();
initLaserTab(); // Initialize laser position/coverage
draw();

if (restored) {
    showToast('‚úì Restored last session', 2000);
}
</script>
<script>
if("serviceWorker" in navigator) navigator.serviceWorker.register("sw.js");
</script>
</body>
</html>
